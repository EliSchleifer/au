{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"au : a C++ units library, by Aurora \u00b6 This will be the main page for the documentation website in the future. For now, let's double check a few features to make sure they work. Testing: au.hh Feature tests \u00b6 Tabs \u00b6 Tab A Tab B Contents of tab A. Contents of tab A. Can include code blocks: int main ( int argc , char ** argv ) { return 0 ; } \\LaTeX \\LaTeX math \u00b6 Inline: x = x_0 + v_0 t + \\frac{1}{2} a t^2 x = x_0 + v_0 t + \\frac{1}{2} a t^2 . Block: e_i e_j + e_j e_i = \\delta_{ij} e_i e_j + e_j e_i = \\delta_{ij} Emoji \u00b6 Admonitions \u00b6 Warning Be careful!","title":"`au`: a C++ units library, by Aurora"},{"location":"#au-a-c-units-library-by-aurora","text":"This will be the main page for the documentation website in the future. For now, let's double check a few features to make sure they work. Testing: au.hh","title":"au: a C++ units library, by Aurora"},{"location":"#feature-tests","text":"","title":"Feature tests"},{"location":"#tabs","text":"Tab A Tab B Contents of tab A. Contents of tab A. Can include code blocks: int main ( int argc , char ** argv ) { return 0 ; }","title":"Tabs"},{"location":"#latexlatex-math","text":"Inline: x = x_0 + v_0 t + \\frac{1}{2} a t^2 x = x_0 + v_0 t + \\frac{1}{2} a t^2 . Block: e_i e_j + e_j e_i = \\delta_{ij} e_i e_j + e_j e_i = \\delta_{ij}","title":"\\LaTeX\\LaTeX math"},{"location":"#emoji","text":"","title":"Emoji"},{"location":"#admonitions","text":"Warning Be careful!","title":"Admonitions"},{"location":"howto/new-units/","text":"Defining new units \u00b6 This page explains how to define new units that aren't included in the library. Tip If it's a common unit---one which should be in the library, but isn't ---go ahead and file an issue ! We should be able to turn it around pretty quickly (either adding it to the library, or explaining why we won't). Definition features \u00b6 Many libraries provide \"convenience\" macros for creating new units, but ours tries to avoid macros completely. 1 Instead, you define new units by just writing regular C++ code. There are several pieces you can add, each of which provides some particular feature. Here is a complete sample definition of a new Unit, with these features annotated and explained. C++14 C++17 or later // Example custom unit definition below. // // Items labeled with `*` are _required_; everything else is optional. // In .hh file: struct Fathoms : decltype ( Inches {} * mag < 72 > ()) { // *[1] static constexpr const char label [] = \"ftm\" ; // [2a] }; constexpr auto fathom = SingularNameFor < Fathoms > {}; // [3] constexpr auto fathoms = QuantityMaker < Fathoms > {}; // *[4] constexpr auto fathoms_pt = QuantityPointMaker < Fathoms > {}; // [5; less common] // In .cc file: constexpr const char Fathoms :: label []; // [2b] // Example custom unit definition below. // // Items labeled with `*` are _required_; everything else is optional. // In .hh file: struct Fathoms : decltype ( Inches {} * mag < 72 > ()) { // *[1] static constexpr inline const char label [] = \"ftm\" ; // [2] }; constexpr auto fathom = SingularNameFor < Fathoms > {}; // [3] constexpr auto fathoms = QuantityMaker < Fathoms > {}; // *[4] constexpr auto fathoms_pt = QuantityPointMaker < Fathoms > {}; // [5; less common] Note If you've seen the unit definitions included in our library, you may notice they look a little different from the above. That's because the library has different goals and constraints than end user projects have. For example, the library needs to be both C++14-compatible and header-only. This forces us to define our labels in a more complicated way. By contrast, your project is unlikely to have both these constraints. Prefer the simpler approach outlined in this page, instead of treating our library's source code definitions as examples to follow. Here are the features. Strong type definition . Required. Make a struct with the name you want, and inherit from decltype(u) , where u is some unit expression which gives it the right Dimension and Magnitude. (We'll explain unit expressions in the next section.) Label . A sizeof() -compatible label which is useful for printing the Unit. Note that if your project needs C++14 compatibility, then besides the label itself ( [2a] ), you'll need to provide a definition ( [2b] ) in the .cc file. By contrast, if you use C++17 or later, you can just use an inline variable, and you won't need a .cc file. If omitted: Everything will still work ; your Quantity will just be labeled as [UNLABELED UNIT] in printing contexts. Singular name . An object whose name is the singular name for your unit. Useful in certain contexts: for example, the traditional unit for torque is \" newton meters\", not \" newtons meters\". If omitted: you'll sacrifice some readability flow: the grammar becomes strange. You'll end up with constructs like speed.in(miles / hours) , rather than speed.in(miles / hour) . 2 Quantity maker . Required. This gives you a snake_case version of your unit which acts like a function. If you call this \"function\" and pass it any numeric type, it creates a Quantity of your unit , whose Rep is that type. Of course, a quantity maker is much more than a function: it composes nicely with prefixes, and with other quantity makers. Quantity point maker . Just like the quantity maker, but conventionally with a _pt suffix to indicate that it makes QuantityPoint instead. You can call this like a function on arbitrary numeric types. You can also compose it with prefixes, or scale it with Magnitudes. If omitted: this is usually fine to omit: most Units are only used with Quantity , not QuantityPoint . Note Not shown here: adding an origin member. We skipped this because it is very rare. It only has any effect at all for Units you plan to use with QuantityPoint , which is not the usual case. Even among those units, only a small subset have a non-default origin. The main examples are Celsius and Fahrenheit , and the library will provide those out of the box. Unit expressions \u00b6 Above, we said to inherit your unit's strong type from the decltype of a \"unit expression\". Recall the line from above: struct Fathoms : decltype ( Inches {} * mag < 72 > ()) { // Unit Expression ^^^^^^^^^^^^^^^^^^^^ This section explains what kinds of things can go inside of the decltype(...) . Conceptually, units are defined by combining other units . In general, given any set of units, you can multiply them, divide them, raise them to powers, or scale them by real numbers (\"magnitudes\"): the result of any of these operations defines a new unit. In C++ code, the easiest way to do this is by working with instances of the unit types. ( Meters is the type ; Meters{} is an instance of the type.) This lets us multiply them naturally by writing * , rather than using cumbersome template traits such as UnitProductT<...> . Here are some examples: Newtons: Kilo<Grams>{} * Meters{} / squared(Seconds{}) Miles: Feet{} * mag<5280>() Degrees: Radians{} * PI / mag<180>() Aliases vs. strong types: best practices \u00b6 A shorter method of defining units is as aliases for a compound unit. For example: using MilesPerHour = decltype ( Miles {} / Hours {}); constexpr auto miles_per_hour = miles / hour ; We can use the alias, MilesPerHour , anywhere we'd use a unit type. And we can call the QuantityMaker, miles_per_hour , just as we would call miles . 3 We even get an automatically generated unit label: mi / h . Despite this convenience, aliases aren't always the best choice. Here's the best practices guidance to follow. Use strong types for named units. Example: Newtons ; Fathoms Rationale: Strong types show up in compiler errors, making them easier to read. Counterpoint: as seen below, this will reduce the ability to cancel out units. For example, Meters{} * Hertz{} will not be the same as Meters{} / Seconds{} ; instead, it will be a different-but-equivalent Unit. Given the way we handle quantity-equivalent Units, this will usually not be a problem, and we believe the value of seeing shorter, more familiar names in the compiler errors outweighs this cost. Use aliases for compound units with no special name. Example: NewtonMeters ; MilesPerHour . Both of these are better implemented as aliases rather than strong types . Rationale: Keeping these as aliases increases support for cancellation: it enables the library to notice that MetersPerSecond{} * Seconds{} is identical to Meters{} , not merely quantity-equivalent. This doesn't usually matter, but it can reduce exposure to compiler errors in the (rare) situations where exact-type-equality matters (e.g., initializer lists). Macros have long been considered contrary to C++ best practices. If we're going to use one, especially in user-facing code, it needs to meet a very high bar. Unit definition macros don't meet this bar. They mostly exist to save typing. But code is read far more often than written, and macros actually make the definitions harder to read and understand (because they use positional arguments, so the meaning of the parameters is unclear at the callsite). \u21a9 Note that this requires us to build out multiplication and division between two QuantityMaker instances, rather than just a QuantityMaker and a SingularNameFor . We haven't done this yet, but it's inevitable that we will, to support composing units whose singular name is identical to the plural name (e.g., hertz ). \u21a9 Note that we don't \"need\" to define this. We could write (miles / hour)(65) , and get exactly the same result as miles_per_hour(65) . However, some users may prefer the latter syntax. \u21a9","title":"Defining new units"},{"location":"howto/new-units/#defining-new-units","text":"This page explains how to define new units that aren't included in the library. Tip If it's a common unit---one which should be in the library, but isn't ---go ahead and file an issue ! We should be able to turn it around pretty quickly (either adding it to the library, or explaining why we won't).","title":"Defining new units"},{"location":"howto/new-units/#definition-features","text":"Many libraries provide \"convenience\" macros for creating new units, but ours tries to avoid macros completely. 1 Instead, you define new units by just writing regular C++ code. There are several pieces you can add, each of which provides some particular feature. Here is a complete sample definition of a new Unit, with these features annotated and explained. C++14 C++17 or later // Example custom unit definition below. // // Items labeled with `*` are _required_; everything else is optional. // In .hh file: struct Fathoms : decltype ( Inches {} * mag < 72 > ()) { // *[1] static constexpr const char label [] = \"ftm\" ; // [2a] }; constexpr auto fathom = SingularNameFor < Fathoms > {}; // [3] constexpr auto fathoms = QuantityMaker < Fathoms > {}; // *[4] constexpr auto fathoms_pt = QuantityPointMaker < Fathoms > {}; // [5; less common] // In .cc file: constexpr const char Fathoms :: label []; // [2b] // Example custom unit definition below. // // Items labeled with `*` are _required_; everything else is optional. // In .hh file: struct Fathoms : decltype ( Inches {} * mag < 72 > ()) { // *[1] static constexpr inline const char label [] = \"ftm\" ; // [2] }; constexpr auto fathom = SingularNameFor < Fathoms > {}; // [3] constexpr auto fathoms = QuantityMaker < Fathoms > {}; // *[4] constexpr auto fathoms_pt = QuantityPointMaker < Fathoms > {}; // [5; less common] Note If you've seen the unit definitions included in our library, you may notice they look a little different from the above. That's because the library has different goals and constraints than end user projects have. For example, the library needs to be both C++14-compatible and header-only. This forces us to define our labels in a more complicated way. By contrast, your project is unlikely to have both these constraints. Prefer the simpler approach outlined in this page, instead of treating our library's source code definitions as examples to follow. Here are the features. Strong type definition . Required. Make a struct with the name you want, and inherit from decltype(u) , where u is some unit expression which gives it the right Dimension and Magnitude. (We'll explain unit expressions in the next section.) Label . A sizeof() -compatible label which is useful for printing the Unit. Note that if your project needs C++14 compatibility, then besides the label itself ( [2a] ), you'll need to provide a definition ( [2b] ) in the .cc file. By contrast, if you use C++17 or later, you can just use an inline variable, and you won't need a .cc file. If omitted: Everything will still work ; your Quantity will just be labeled as [UNLABELED UNIT] in printing contexts. Singular name . An object whose name is the singular name for your unit. Useful in certain contexts: for example, the traditional unit for torque is \" newton meters\", not \" newtons meters\". If omitted: you'll sacrifice some readability flow: the grammar becomes strange. You'll end up with constructs like speed.in(miles / hours) , rather than speed.in(miles / hour) . 2 Quantity maker . Required. This gives you a snake_case version of your unit which acts like a function. If you call this \"function\" and pass it any numeric type, it creates a Quantity of your unit , whose Rep is that type. Of course, a quantity maker is much more than a function: it composes nicely with prefixes, and with other quantity makers. Quantity point maker . Just like the quantity maker, but conventionally with a _pt suffix to indicate that it makes QuantityPoint instead. You can call this like a function on arbitrary numeric types. You can also compose it with prefixes, or scale it with Magnitudes. If omitted: this is usually fine to omit: most Units are only used with Quantity , not QuantityPoint . Note Not shown here: adding an origin member. We skipped this because it is very rare. It only has any effect at all for Units you plan to use with QuantityPoint , which is not the usual case. Even among those units, only a small subset have a non-default origin. The main examples are Celsius and Fahrenheit , and the library will provide those out of the box.","title":"Definition features"},{"location":"howto/new-units/#unit-expressions","text":"Above, we said to inherit your unit's strong type from the decltype of a \"unit expression\". Recall the line from above: struct Fathoms : decltype ( Inches {} * mag < 72 > ()) { // Unit Expression ^^^^^^^^^^^^^^^^^^^^ This section explains what kinds of things can go inside of the decltype(...) . Conceptually, units are defined by combining other units . In general, given any set of units, you can multiply them, divide them, raise them to powers, or scale them by real numbers (\"magnitudes\"): the result of any of these operations defines a new unit. In C++ code, the easiest way to do this is by working with instances of the unit types. ( Meters is the type ; Meters{} is an instance of the type.) This lets us multiply them naturally by writing * , rather than using cumbersome template traits such as UnitProductT<...> . Here are some examples: Newtons: Kilo<Grams>{} * Meters{} / squared(Seconds{}) Miles: Feet{} * mag<5280>() Degrees: Radians{} * PI / mag<180>()","title":"Unit expressions"},{"location":"howto/new-units/#aliases-vs-strong-types-best-practices","text":"A shorter method of defining units is as aliases for a compound unit. For example: using MilesPerHour = decltype ( Miles {} / Hours {}); constexpr auto miles_per_hour = miles / hour ; We can use the alias, MilesPerHour , anywhere we'd use a unit type. And we can call the QuantityMaker, miles_per_hour , just as we would call miles . 3 We even get an automatically generated unit label: mi / h . Despite this convenience, aliases aren't always the best choice. Here's the best practices guidance to follow. Use strong types for named units. Example: Newtons ; Fathoms Rationale: Strong types show up in compiler errors, making them easier to read. Counterpoint: as seen below, this will reduce the ability to cancel out units. For example, Meters{} * Hertz{} will not be the same as Meters{} / Seconds{} ; instead, it will be a different-but-equivalent Unit. Given the way we handle quantity-equivalent Units, this will usually not be a problem, and we believe the value of seeing shorter, more familiar names in the compiler errors outweighs this cost. Use aliases for compound units with no special name. Example: NewtonMeters ; MilesPerHour . Both of these are better implemented as aliases rather than strong types . Rationale: Keeping these as aliases increases support for cancellation: it enables the library to notice that MetersPerSecond{} * Seconds{} is identical to Meters{} , not merely quantity-equivalent. This doesn't usually matter, but it can reduce exposure to compiler errors in the (rare) situations where exact-type-equality matters (e.g., initializer lists). Macros have long been considered contrary to C++ best practices. If we're going to use one, especially in user-facing code, it needs to meet a very high bar. Unit definition macros don't meet this bar. They mostly exist to save typing. But code is read far more often than written, and macros actually make the definitions harder to read and understand (because they use positional arguments, so the meaning of the parameters is unclear at the callsite). \u21a9 Note that this requires us to build out multiplication and division between two QuantityMaker instances, rather than just a QuantityMaker and a SingularNameFor . We haven't done this yet, but it's inevitable that we will, to support composing units whose singular name is identical to the plural name (e.g., hertz ). \u21a9 Note that we don't \"need\" to define this. We could write (miles / hour)(65) , and get exactly the same result as miles_per_hour(65) . However, some users may prefer the latter syntax. \u21a9","title":"Aliases vs. strong types: best practices"}]}