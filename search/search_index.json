{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"au : a C++ units library, by Aurora \u00b6 This will be the main page for the documentation website in the future. For now, let\u2019s double check a few features to make sure they work. Feature tests \u00b6 Tabs \u00b6 Tab A Tab B Contents of tab A. Contents of tab A. Can include code blocks: int main ( int argc , char ** argv ) { return 0 ; } \\LaTeX \\LaTeX math \u00b6 Inline: x = x_0 + v_0 t + \\frac{1}{2} a t^2 x = x_0 + v_0 t + \\frac{1}{2} a t^2 . Block: e_i e_j + e_j e_i = \\delta_{ij} e_i e_j + e_j e_i = \\delta_{ij} Emoji \u00b6 Admonitions \u00b6 Warning Be careful!","title":"`au`: a C++ units library, by Aurora"},{"location":"#au-a-c-units-library-by-aurora","text":"This will be the main page for the documentation website in the future. For now, let\u2019s double check a few features to make sure they work.","title":"au: a C++ units library, by Aurora"},{"location":"#feature-tests","text":"","title":"Feature tests"},{"location":"#tabs","text":"Tab A Tab B Contents of tab A. Contents of tab A. Can include code blocks: int main ( int argc , char ** argv ) { return 0 ; }","title":"Tabs"},{"location":"#latexlatex-math","text":"Inline: x = x_0 + v_0 t + \\frac{1}{2} a t^2 x = x_0 + v_0 t + \\frac{1}{2} a t^2 . Block: e_i e_j + e_j e_i = \\delta_{ij} e_i e_j + e_j e_i = \\delta_{ij}","title":"\\LaTeX\\LaTeX math"},{"location":"#emoji","text":"","title":"Emoji"},{"location":"#admonitions","text":"Warning Be careful!","title":"Admonitions"},{"location":"install/","text":"Installation \u00b6 Au can be installed in multiple ways. First, we\u2019ll help you decide which one is right for you. Then, we\u2019ll provide full instructions for each option. Broadly, you can either do a \u201cfull install\u201d of the library, or you can package it into a single header file. For the latter approach, there are two options: Pre-built versions you can download right away. Custom versions with exactly the units you choose. Choosing a method \u00b6 You should consider several factors before you decide how to install the Au library, such as: Tradeoffs in setup time, unit selection, and flexibility. Whether you\u2019re installing for production, or just trying it out. Your build system. Here\u2019s an overview of the tradeoffs involved. Legend Unsupported Fair Good Best Single File Full Install Pre-built Custom bazel CMake, conan, vcpkg, ... Setup time ~1 min ~10 min ~10 min Not yet supported (use single-file instead for now) Unit selection Base units only Any units desired Any units desired, without needing \"reinstall\" Compile time cost ~10 units Very competitive up to a few dozen units Each file only pays for the units it uses Flexibility Awkward: would need to download io.hh and/or testing.hh separately, and modify their includes manually Include I/O, testing utilities, individual units as desired, on a per-file basis So, which should you use? graph TD Usage[What's your use case?] SetupTime[Got 10 minutes for setup?] BuildSystem[What's your build system?] UsePreBuilt[Use pre-built single file] UseCustom[Use custom single file] UseFullInstall[Use full install] Usage -->|Just playing around with Au| SetupTime SetupTime -->|No! Just let me start!| UsePreBuilt SetupTime -->|Sure| UseCustom Usage -->|Ready to use in my project!| BuildSystem BuildSystem -->|bazel| UseFullInstall BuildSystem -->|other| UseCustom Installation instructions \u00b6 Here are the instructions for each installation method we support. Single file \u00b6 The Au library can be packaged as a single header file, which you can include in your project just like any other header. This works with any build system! To take this approach, obtain the single file by one of the methods described below. Then, put it inside a third_party folder (for example, as third_party/au.hh ). Now you\u2019re up and running with Au! Every single-file package automatically includes the following features: Warning Before public release, we should ensure each of the following items has a documentation page, and link to that page here: Basic \u201cunit container\u201d types: Quantity , QuantityPoint Magnitude types and values, including the constant PI , and constants for any integer such as mag<5280>() . All prefixes for SI ( kilo , mega , \u2026) and informational ( kibi , mebi , \u2026) quantities. Math functions, including unit-aware rounding and inverses, trigonometric functions, square roots, and so on. Bidirectional implicit conversion between Quantity types and any equivalent counterparts in the std::chrono library. Here are the two ways to get a single-file packaging of the library. Pre-built single file \u00b6 Tip This approach is mainly for playing with the library. It\u2019s very fast to get up and running, but it\u2019s not the best choice as the \u201cproduction\u201d installation of your library. For a single-file approach, most users will be much better served by the next section, which explains how to customize it to get exactly the units you want. We provide pre-generated single-file versions of the library, automatically generated from the latest commit in the repo: au.hh au_noio.hh (Same as above, but with <iostream> support stripped out) These include very few units (to keep compile times short). However, combinations of these units should get you any other unit you\u2019re likely to want. The units we include are: Every SI base unit ( seconds , meters , kilo(grams) , amperes , kelvins , moles , candelas ) Base units for angles and information ( radians , bits ) A base dimensionless unit ( unos ) Note How do you go about constructing other units from these? By composing them. For example, you can make other coherent SI units like this: constexpr auto newtons = kilo ( gram ) * meters / squared ( second ); Now you can call, say, newtons(10) and get a quantity equivalent to 10 Newtons. You can also scale a unit by multiplying by Magnitude objects. For example: constexpr auto degrees = radians * PI / mag < 180 > (); These will \u201cwork\u201d, in the sense of producing correct results. But these ad hoc unit definitions are far less usable than fully defined units . Both the type names and the unit symbols will be needlessly complicated. Again, we recommend following the directions in the next section to get exactly the units you care about. Custom single file \u00b6 It\u2019s easy to package the library in a custom single file with exactly the units you need. Here\u2019s how: Clone the repo . Go to the aurora-opensource/au repo, and follow the typical instructions. If you\u2019re just a user of Au, not a contributor , this should be: git clone https://github.com/aurora-opensource/au.git Run the script . tools/bin/make-single-file --units meters seconds newtons > ~/au.hh creates a file, ~/au.hh , which packages the entire library in a single file with these three units. To see the full list of available units, search the .hh files in the au/units/ folder. For example, meters will include the contents of au/units/meters.hh . Provide the --noio flag if you prefer to avoid the expense of the <iostream> library. Now you have a file, ~/au.hh , which you can add to your third_party folder. Full library installation \u00b6 bazel \u00b6 Warning These instructions were written while the Au repo was still private. Therefore, we couldn\u2019t fully test that they actually work . However, when adding a backup file:/// URL pointing to a manually downloaded copy, they did work, which is a very promising sign. Choose your Au version . This can be a tag, or a commit hash. Let\u2019s take 0.2.0 as an example. Form the URL to the archive . For 0.2.0 , this would be: https://github.com/aurora-opensource/au/archive/0.2.0.tar.gz NOTE: Your au version ID goes HERE ^^^^^ Compute your SHA256 hash . Follow the URL from the previous step to download the archive. Compute the SHA256 hash: sha256sum au-0.2.0.tar.gz The first token that appears is the hash. Save it for the next step. Add http_archive rule to WORKSPACE . Follow this pattern: http_archive ( name = \"au\" , sha256 = \"bdaec065b35f44af2cb22def5b69ac08ca40c47791ea3ed2eb3ebf3e85b3e0b0\" , strip_prefix = \"au-0.2.0\" , urls = [ \"https://github.com/aurora-opensource/au/archive/0.2.0.tar.gz\" ], ) In particular, here\u2019s how to fill out the fields: sha256 : Use the SHA256 hash you got from step 3. strip_prefix : write \"au-0.2.0\" , except use your ID from step 1 instead of 0.2.0 . urls : This should be a list, whose only entry is the URL you formed in step 2. At this point, the Au library is installed, and you can use it in your project! Here are the headers provided by each Au target. To use, add the \u201cDependency\u201d to your deps attribute, and include the appropriate files. Dependency Headers provided Notes @au//au \"au/au.hh\" \"au/units.*.hh\" Core library functionality. See all available units @au//au:io \"au/io.hh\" operator<< support @au//au:testing \"au/testing.hh\" Utilities for testing Note: testonly = True Other build systems (CMake / conan / vcpkg / \u2026) \u00b6 We would like to support all these build and packaging systems, and perhaps others! But the initial public release is bazel-only, because bazel is what we use at Aurora, and we don\u2019t have experience with any of these alternatives. Thus, we\u2019ll need to lean on the community to support them. Meanwhile, the library itself is still at least partially available on all build environments, via the single-file options explained above.","title":"Installation"},{"location":"install/#installation","text":"Au can be installed in multiple ways. First, we\u2019ll help you decide which one is right for you. Then, we\u2019ll provide full instructions for each option. Broadly, you can either do a \u201cfull install\u201d of the library, or you can package it into a single header file. For the latter approach, there are two options: Pre-built versions you can download right away. Custom versions with exactly the units you choose.","title":"Installation"},{"location":"install/#choosing-a-method","text":"You should consider several factors before you decide how to install the Au library, such as: Tradeoffs in setup time, unit selection, and flexibility. Whether you\u2019re installing for production, or just trying it out. Your build system. Here\u2019s an overview of the tradeoffs involved. Legend Unsupported Fair Good Best Single File Full Install Pre-built Custom bazel CMake, conan, vcpkg, ... Setup time ~1 min ~10 min ~10 min Not yet supported (use single-file instead for now) Unit selection Base units only Any units desired Any units desired, without needing \"reinstall\" Compile time cost ~10 units Very competitive up to a few dozen units Each file only pays for the units it uses Flexibility Awkward: would need to download io.hh and/or testing.hh separately, and modify their includes manually Include I/O, testing utilities, individual units as desired, on a per-file basis So, which should you use? graph TD Usage[What's your use case?] SetupTime[Got 10 minutes for setup?] BuildSystem[What's your build system?] UsePreBuilt[Use pre-built single file] UseCustom[Use custom single file] UseFullInstall[Use full install] Usage -->|Just playing around with Au| SetupTime SetupTime -->|No! Just let me start!| UsePreBuilt SetupTime -->|Sure| UseCustom Usage -->|Ready to use in my project!| BuildSystem BuildSystem -->|bazel| UseFullInstall BuildSystem -->|other| UseCustom","title":"Choosing a method"},{"location":"install/#installation-instructions","text":"Here are the instructions for each installation method we support.","title":"Installation instructions"},{"location":"install/#single-file","text":"The Au library can be packaged as a single header file, which you can include in your project just like any other header. This works with any build system! To take this approach, obtain the single file by one of the methods described below. Then, put it inside a third_party folder (for example, as third_party/au.hh ). Now you\u2019re up and running with Au! Every single-file package automatically includes the following features: Warning Before public release, we should ensure each of the following items has a documentation page, and link to that page here: Basic \u201cunit container\u201d types: Quantity , QuantityPoint Magnitude types and values, including the constant PI , and constants for any integer such as mag<5280>() . All prefixes for SI ( kilo , mega , \u2026) and informational ( kibi , mebi , \u2026) quantities. Math functions, including unit-aware rounding and inverses, trigonometric functions, square roots, and so on. Bidirectional implicit conversion between Quantity types and any equivalent counterparts in the std::chrono library. Here are the two ways to get a single-file packaging of the library.","title":"Single file"},{"location":"install/#pre-built-single-file","text":"Tip This approach is mainly for playing with the library. It\u2019s very fast to get up and running, but it\u2019s not the best choice as the \u201cproduction\u201d installation of your library. For a single-file approach, most users will be much better served by the next section, which explains how to customize it to get exactly the units you want. We provide pre-generated single-file versions of the library, automatically generated from the latest commit in the repo: au.hh au_noio.hh (Same as above, but with <iostream> support stripped out) These include very few units (to keep compile times short). However, combinations of these units should get you any other unit you\u2019re likely to want. The units we include are: Every SI base unit ( seconds , meters , kilo(grams) , amperes , kelvins , moles , candelas ) Base units for angles and information ( radians , bits ) A base dimensionless unit ( unos ) Note How do you go about constructing other units from these? By composing them. For example, you can make other coherent SI units like this: constexpr auto newtons = kilo ( gram ) * meters / squared ( second ); Now you can call, say, newtons(10) and get a quantity equivalent to 10 Newtons. You can also scale a unit by multiplying by Magnitude objects. For example: constexpr auto degrees = radians * PI / mag < 180 > (); These will \u201cwork\u201d, in the sense of producing correct results. But these ad hoc unit definitions are far less usable than fully defined units . Both the type names and the unit symbols will be needlessly complicated. Again, we recommend following the directions in the next section to get exactly the units you care about.","title":"Pre-built single file"},{"location":"install/#custom-single-file","text":"It\u2019s easy to package the library in a custom single file with exactly the units you need. Here\u2019s how: Clone the repo . Go to the aurora-opensource/au repo, and follow the typical instructions. If you\u2019re just a user of Au, not a contributor , this should be: git clone https://github.com/aurora-opensource/au.git Run the script . tools/bin/make-single-file --units meters seconds newtons > ~/au.hh creates a file, ~/au.hh , which packages the entire library in a single file with these three units. To see the full list of available units, search the .hh files in the au/units/ folder. For example, meters will include the contents of au/units/meters.hh . Provide the --noio flag if you prefer to avoid the expense of the <iostream> library. Now you have a file, ~/au.hh , which you can add to your third_party folder.","title":"Custom single file"},{"location":"install/#full-library-installation","text":"","title":"Full library installation"},{"location":"install/#bazel","text":"Warning These instructions were written while the Au repo was still private. Therefore, we couldn\u2019t fully test that they actually work . However, when adding a backup file:/// URL pointing to a manually downloaded copy, they did work, which is a very promising sign. Choose your Au version . This can be a tag, or a commit hash. Let\u2019s take 0.2.0 as an example. Form the URL to the archive . For 0.2.0 , this would be: https://github.com/aurora-opensource/au/archive/0.2.0.tar.gz NOTE: Your au version ID goes HERE ^^^^^ Compute your SHA256 hash . Follow the URL from the previous step to download the archive. Compute the SHA256 hash: sha256sum au-0.2.0.tar.gz The first token that appears is the hash. Save it for the next step. Add http_archive rule to WORKSPACE . Follow this pattern: http_archive ( name = \"au\" , sha256 = \"bdaec065b35f44af2cb22def5b69ac08ca40c47791ea3ed2eb3ebf3e85b3e0b0\" , strip_prefix = \"au-0.2.0\" , urls = [ \"https://github.com/aurora-opensource/au/archive/0.2.0.tar.gz\" ], ) In particular, here\u2019s how to fill out the fields: sha256 : Use the SHA256 hash you got from step 3. strip_prefix : write \"au-0.2.0\" , except use your ID from step 1 instead of 0.2.0 . urls : This should be a list, whose only entry is the URL you formed in step 2. At this point, the Au library is installed, and you can use it in your project! Here are the headers provided by each Au target. To use, add the \u201cDependency\u201d to your deps attribute, and include the appropriate files. Dependency Headers provided Notes @au//au \"au/au.hh\" \"au/units.*.hh\" Core library functionality. See all available units @au//au:io \"au/io.hh\" operator<< support @au//au:testing \"au/testing.hh\" Utilities for testing Note: testonly = True","title":"bazel"},{"location":"install/#other-build-systems-cmake-conan-vcpkg","text":"We would like to support all these build and packaging systems, and perhaps others! But the initial public release is bazel-only, because bazel is what we use at Aurora, and we don\u2019t have experience with any of these alternatives. Thus, we\u2019ll need to lean on the community to support them. Meanwhile, the library itself is still at least partially available on all build environments, via the single-file options explained above.","title":"Other build systems (CMake / conan / vcpkg / ...)"},{"location":"howto/new-units/","text":"Defining new units \u00b6 This page explains how to define new units that aren\u2019t included in the library. Tip If it\u2019s a common unit\u2014one which should be in the library, but isn\u2019t \u2014go ahead and file an issue ! We should be able to turn it around pretty quickly (either adding it to the library, or explaining why we won\u2019t). Definition features \u00b6 Many libraries provide \u201cconvenience\u201d macros for creating new units, but ours tries to avoid macros completely. 1 Instead, you define new units by just writing regular C++ code. There are several pieces you can add, each of which provides some particular feature. Here is a complete sample definition of a new Unit, with these features annotated and explained. C++14 C++17 or later // Example custom unit definition below. // // Items labeled with `*` are _required_; everything else is optional. // In .hh file: struct Fathoms : decltype ( Inches {} * mag < 72 > ()) { // *[1] static constexpr const char label [] = \"ftm\" ; // [2a] }; constexpr auto fathom = SingularNameFor < Fathoms > {}; // [3] constexpr auto fathoms = QuantityMaker < Fathoms > {}; // *[4] constexpr auto fathoms_pt = QuantityPointMaker < Fathoms > {}; // [5; less common] // In .cc file: constexpr const char Fathoms :: label []; // [2b] // Example custom unit definition below. // // Items labeled with `*` are _required_; everything else is optional. // In .hh file: struct Fathoms : decltype ( Inches {} * mag < 72 > ()) { // *[1] static constexpr inline const char label [] = \"ftm\" ; // [2] }; constexpr auto fathom = SingularNameFor < Fathoms > {}; // [3] constexpr auto fathoms = QuantityMaker < Fathoms > {}; // *[4] constexpr auto fathoms_pt = QuantityPointMaker < Fathoms > {}; // [5; less common] Note If you\u2019ve seen the unit definitions included in our library, you may notice they look a little different from the above. That\u2019s because the library has different goals and constraints than end user projects have. For example, the library needs to be both C++14-compatible and header-only. This forces us to define our labels in a more complicated way. By contrast, your project is unlikely to have both these constraints. Prefer the simpler approach outlined in this page, instead of treating our library\u2019s source code definitions as examples to follow. Here are the features. Strong type definition . Required. Make a struct with the name you want, and inherit from decltype(u) , where u is some unit expression which gives it the right Dimension and Magnitude. (We\u2019ll explain unit expressions in the next section.) Label . A sizeof() -compatible label which is useful for printing the Unit. Note that if your project needs C++14 compatibility, then besides the label itself ( [2a] ), you\u2019ll need to provide a definition ( [2b] ) in the .cc file. By contrast, if you use C++17 or later, you can just use an inline variable, and you won\u2019t need a .cc file. If omitted: Everything will still work ; your Quantity will just be labeled as [UNLABELED UNIT] in printing contexts. Singular name . An object whose name is the singular name for your unit. Useful in certain contexts: for example, the traditional unit for torque is \u201c newton meters\u201d, not \u201c newtons meters\u201d. If omitted: you\u2019ll sacrifice some readability flow: the grammar becomes strange. You\u2019ll end up with constructs like speed.in(miles / hours) , rather than speed.in(miles / hour) . 2 Quantity maker . Required. This gives you a snake_case version of your unit which acts like a function. If you call this \u201cfunction\u201d and pass it any numeric type, it creates a Quantity of your unit , whose Rep is that type. Of course, a quantity maker is much more than a function: it composes nicely with prefixes, and with other quantity makers. Quantity point maker . Just like the quantity maker, but conventionally with a _pt suffix to indicate that it makes QuantityPoint instead. You can call this like a function on arbitrary numeric types. You can also compose it with prefixes, or scale it with Magnitudes. If omitted: this is usually fine to omit: most Units are only used with Quantity , not QuantityPoint . Note Not shown here: adding an origin member. We skipped this because it is very rare. It only has any effect at all for Units you plan to use with QuantityPoint , which is not the usual case. Even among those units, only a small subset have a non-default origin. The main examples are Celsius and Fahrenheit , and the library will provide those out of the box. Unit expressions \u00b6 Above, we said to inherit your unit\u2019s strong type from the decltype of a \u201cunit expression\u201d. Recall the line from above: struct Fathoms : decltype ( Inches {} * mag < 72 > ()) { // Unit Expression ^^^^^^^^^^^^^^^^^^^^ This section explains what kinds of things can go inside of the decltype(...) . Conceptually, units are defined by combining other units . In general, given any set of units, you can multiply them, divide them, raise them to powers, or scale them by real numbers (\u201cmagnitudes\u201d): the result of any of these operations defines a new unit. In C++ code, the easiest way to do this is by working with instances of the unit types. ( Meters is the type ; Meters{} is an instance of the type.) This lets us multiply them naturally by writing * , rather than using cumbersome template traits such as UnitProductT<...> . Here are some examples: Newtons: Kilo<Grams>{} * Meters{} / squared(Seconds{}) Miles: Feet{} * mag<5280>() Degrees: Radians{} * PI / mag<180>() Aliases vs. strong types: best practices \u00b6 A shorter method of defining units is as aliases for a compound unit. For example: using MilesPerHour = decltype ( Miles {} / Hours {}); constexpr auto miles_per_hour = miles / hour ; We can use the alias, MilesPerHour , anywhere we\u2019d use a unit type. And we can call the QuantityMaker, miles_per_hour , just as we would call miles . 3 We even get an automatically generated unit label: mi / h . Despite this convenience, aliases aren\u2019t always the best choice. Here\u2019s the best practices guidance to follow. Use strong types for named units. Example: Newtons ; Fathoms Rationale: Strong types show up in compiler errors, making them easier to read. Counterpoint: as seen below, this will reduce the ability to cancel out units. For example, Meters{} * Hertz{} will not be the same as Meters{} / Seconds{} ; instead, it will be a different-but-equivalent Unit. Given the way we handle quantity-equivalent Units, this will usually not be a problem, and we believe the value of seeing shorter, more familiar names in the compiler errors outweighs this cost. Use aliases for compound units with no special name. Example: NewtonMeters ; MilesPerHour . Both of these are better implemented as aliases rather than strong types . Rationale: Keeping these as aliases increases support for cancellation: it enables the library to notice that MetersPerSecond{} * Seconds{} is identical to Meters{} , not merely quantity-equivalent. This doesn\u2019t usually matter, but it can reduce exposure to compiler errors in the (rare) situations where exact-type-equality matters (e.g., initializer lists). Macros have long been considered contrary to C++ best practices. If we\u2019re going to use one, especially in user-facing code, it needs to meet a very high bar. Unit definition macros don\u2019t meet this bar. They mostly exist to save typing. But code is read far more often than written, and macros actually make the definitions harder to read and understand (because they use positional arguments, so the meaning of the parameters is unclear at the callsite). \u21a9 Note that this requires us to build out multiplication and division between two QuantityMaker instances, rather than just a QuantityMaker and a SingularNameFor . We haven\u2019t done this yet, but it\u2019s inevitable that we will, to support composing units whose singular name is identical to the plural name (e.g., hertz ). \u21a9 Note that we don\u2019t \u201cneed\u201d to define this. We could write (miles / hour)(65) , and get exactly the same result as miles_per_hour(65) . However, some users may prefer the latter syntax. \u21a9","title":"Defining new units"},{"location":"howto/new-units/#defining-new-units","text":"This page explains how to define new units that aren\u2019t included in the library. Tip If it\u2019s a common unit\u2014one which should be in the library, but isn\u2019t \u2014go ahead and file an issue ! We should be able to turn it around pretty quickly (either adding it to the library, or explaining why we won\u2019t).","title":"Defining new units"},{"location":"howto/new-units/#definition-features","text":"Many libraries provide \u201cconvenience\u201d macros for creating new units, but ours tries to avoid macros completely. 1 Instead, you define new units by just writing regular C++ code. There are several pieces you can add, each of which provides some particular feature. Here is a complete sample definition of a new Unit, with these features annotated and explained. C++14 C++17 or later // Example custom unit definition below. // // Items labeled with `*` are _required_; everything else is optional. // In .hh file: struct Fathoms : decltype ( Inches {} * mag < 72 > ()) { // *[1] static constexpr const char label [] = \"ftm\" ; // [2a] }; constexpr auto fathom = SingularNameFor < Fathoms > {}; // [3] constexpr auto fathoms = QuantityMaker < Fathoms > {}; // *[4] constexpr auto fathoms_pt = QuantityPointMaker < Fathoms > {}; // [5; less common] // In .cc file: constexpr const char Fathoms :: label []; // [2b] // Example custom unit definition below. // // Items labeled with `*` are _required_; everything else is optional. // In .hh file: struct Fathoms : decltype ( Inches {} * mag < 72 > ()) { // *[1] static constexpr inline const char label [] = \"ftm\" ; // [2] }; constexpr auto fathom = SingularNameFor < Fathoms > {}; // [3] constexpr auto fathoms = QuantityMaker < Fathoms > {}; // *[4] constexpr auto fathoms_pt = QuantityPointMaker < Fathoms > {}; // [5; less common] Note If you\u2019ve seen the unit definitions included in our library, you may notice they look a little different from the above. That\u2019s because the library has different goals and constraints than end user projects have. For example, the library needs to be both C++14-compatible and header-only. This forces us to define our labels in a more complicated way. By contrast, your project is unlikely to have both these constraints. Prefer the simpler approach outlined in this page, instead of treating our library\u2019s source code definitions as examples to follow. Here are the features. Strong type definition . Required. Make a struct with the name you want, and inherit from decltype(u) , where u is some unit expression which gives it the right Dimension and Magnitude. (We\u2019ll explain unit expressions in the next section.) Label . A sizeof() -compatible label which is useful for printing the Unit. Note that if your project needs C++14 compatibility, then besides the label itself ( [2a] ), you\u2019ll need to provide a definition ( [2b] ) in the .cc file. By contrast, if you use C++17 or later, you can just use an inline variable, and you won\u2019t need a .cc file. If omitted: Everything will still work ; your Quantity will just be labeled as [UNLABELED UNIT] in printing contexts. Singular name . An object whose name is the singular name for your unit. Useful in certain contexts: for example, the traditional unit for torque is \u201c newton meters\u201d, not \u201c newtons meters\u201d. If omitted: you\u2019ll sacrifice some readability flow: the grammar becomes strange. You\u2019ll end up with constructs like speed.in(miles / hours) , rather than speed.in(miles / hour) . 2 Quantity maker . Required. This gives you a snake_case version of your unit which acts like a function. If you call this \u201cfunction\u201d and pass it any numeric type, it creates a Quantity of your unit , whose Rep is that type. Of course, a quantity maker is much more than a function: it composes nicely with prefixes, and with other quantity makers. Quantity point maker . Just like the quantity maker, but conventionally with a _pt suffix to indicate that it makes QuantityPoint instead. You can call this like a function on arbitrary numeric types. You can also compose it with prefixes, or scale it with Magnitudes. If omitted: this is usually fine to omit: most Units are only used with Quantity , not QuantityPoint . Note Not shown here: adding an origin member. We skipped this because it is very rare. It only has any effect at all for Units you plan to use with QuantityPoint , which is not the usual case. Even among those units, only a small subset have a non-default origin. The main examples are Celsius and Fahrenheit , and the library will provide those out of the box.","title":"Definition features"},{"location":"howto/new-units/#unit-expressions","text":"Above, we said to inherit your unit\u2019s strong type from the decltype of a \u201cunit expression\u201d. Recall the line from above: struct Fathoms : decltype ( Inches {} * mag < 72 > ()) { // Unit Expression ^^^^^^^^^^^^^^^^^^^^ This section explains what kinds of things can go inside of the decltype(...) . Conceptually, units are defined by combining other units . In general, given any set of units, you can multiply them, divide them, raise them to powers, or scale them by real numbers (\u201cmagnitudes\u201d): the result of any of these operations defines a new unit. In C++ code, the easiest way to do this is by working with instances of the unit types. ( Meters is the type ; Meters{} is an instance of the type.) This lets us multiply them naturally by writing * , rather than using cumbersome template traits such as UnitProductT<...> . Here are some examples: Newtons: Kilo<Grams>{} * Meters{} / squared(Seconds{}) Miles: Feet{} * mag<5280>() Degrees: Radians{} * PI / mag<180>()","title":"Unit expressions"},{"location":"howto/new-units/#aliases-vs-strong-types-best-practices","text":"A shorter method of defining units is as aliases for a compound unit. For example: using MilesPerHour = decltype ( Miles {} / Hours {}); constexpr auto miles_per_hour = miles / hour ; We can use the alias, MilesPerHour , anywhere we\u2019d use a unit type. And we can call the QuantityMaker, miles_per_hour , just as we would call miles . 3 We even get an automatically generated unit label: mi / h . Despite this convenience, aliases aren\u2019t always the best choice. Here\u2019s the best practices guidance to follow. Use strong types for named units. Example: Newtons ; Fathoms Rationale: Strong types show up in compiler errors, making them easier to read. Counterpoint: as seen below, this will reduce the ability to cancel out units. For example, Meters{} * Hertz{} will not be the same as Meters{} / Seconds{} ; instead, it will be a different-but-equivalent Unit. Given the way we handle quantity-equivalent Units, this will usually not be a problem, and we believe the value of seeing shorter, more familiar names in the compiler errors outweighs this cost. Use aliases for compound units with no special name. Example: NewtonMeters ; MilesPerHour . Both of these are better implemented as aliases rather than strong types . Rationale: Keeping these as aliases increases support for cancellation: it enables the library to notice that MetersPerSecond{} * Seconds{} is identical to Meters{} , not merely quantity-equivalent. This doesn\u2019t usually matter, but it can reduce exposure to compiler errors in the (rare) situations where exact-type-equality matters (e.g., initializer lists). Macros have long been considered contrary to C++ best practices. If we\u2019re going to use one, especially in user-facing code, it needs to meet a very high bar. Unit definition macros don\u2019t meet this bar. They mostly exist to save typing. But code is read far more often than written, and macros actually make the definitions harder to read and understand (because they use positional arguments, so the meaning of the parameters is unclear at the callsite). \u21a9 Note that this requires us to build out multiplication and division between two QuantityMaker instances, rather than just a QuantityMaker and a SingularNameFor . We haven\u2019t done this yet, but it\u2019s inevitable that we will, to support composing units whose singular name is identical to the plural name (e.g., hertz ). \u21a9 Note that we don\u2019t \u201cneed\u201d to define this. We could write (miles / hour)(65) , and get exactly the same result as miles_per_hour(65) . However, some users may prefer the latter syntax. \u21a9","title":"Aliases vs. strong types: best practices"},{"location":"tutorial/101-quantity-makers/","text":"Au 101: Quantity Makers \u00b6 This tutorial gives a gentle introduction to the Au library. Time: TBD. Prerequisites: Experience writing C++ code. You will learn: The concept and importance of \u201cunit safety\u201d. How to store a numeric value in a quantity . How to retrieve the stored numeric value. Some basic operations you can perform with a quantity. Status quo: no units library \u00b6 Suppose you have a variable that represents a physical quantity . That variable has some value , but that value is meaningless unless you also know the unit of measurement . We usually indicate the unit with a suffix on the variable name. Here\u2019s a concrete example: const double track_length_m = 100.0 ; // Unit suffix--^^ ^^^^^--Value const double best_time_s = 10.34 ; // Unit suffix--^^ ^^^^^--Value The first value is 100.0 . Since there\u2019s no such thing as a \u201clength of 100\u201d, we add a _m suffix on the end of our variable name to make it clear that the value is the length in meters . We take a similar approach for our time in seconds . This strategy works , in the sense that it can prevent unit errors, but it\u2019s labor intensive and error prone. Consider a function we might want to call: double average_speed_mps ( double length_m , double time_s ); With the above variables, our callsite might look like this: const auto speed_mps = average_speed_mps ( track_length_m , best_time_s ); It\u2019s time to consider a very important property: Definition Unit correctness: a program is unit-correct when every variable associated with physical units is used consistently with those units. So: is this unit-correct? Yes: track_length_m gets passed as the parameter length_m : meters to meters best_time_s gets passed as the parameter time_s : seconds to seconds However, it\u2019s quite fragile. We could just as easily have written the following. const auto speed_mps = average_speed_mps ( best_time_s , track_length_m ); By itself, this line looks correct: we\u2019re asking for an average speed, given a time and a length. We can even see that we\u2019re passing in values in seconds and meters to get a result in meters-per-second, increasing our confidence! Of course, the line is wrong, but the only way to know that it\u2019s wrong is to go read the declaration of average_speed_mps . This could easily be in some other file. In a big project, it might be hard to even figure out which file it\u2019s in. That\u2019s a lot of cognitive load! Our goal: unit safety \u00b6 To write code quickly and robustly, unit-correctness is not enough . We need more: we need unit safety . Definition Unit safety : We call a program unit-safe when the unit-correctness of each line of code can be checked by inspection , in isolation . This is the way to reduce cognitive load for code readers, when it comes to physical units. If you inspect a unit-safe line, and see that it\u2019s correct, then you\u2019re done with that line. You can move on; you don\u2019t have to hold it in your head. Tip A unit-safe line doesn\u2019t guarantee that the program has no unit errors. It does guarantee that if there are unit errors, then they\u2019re in some other line (which you can also inspect!). Unit-safety is not something you could ever get from the standard numeric types, but you can get it from the Au library. Let\u2019s learn how! Storing values: the \u201cquantity maker\u201d \u00b6 The way to achieve unit-safety is by turning our raw numeric values into quantities . We do this with quantity makers . These are callables\u2014things that act like functions\u2014which have the name of some unit , and accept any numeric type . For example, let\u2019s make our variable track_length_m unit-safe by using the quantity maker, meters : const auto track_length = meters ( track_length_m ); // ^^^^^^ ^^ // Quantity maker of *meters* Takes value in *meters* This is an example of a unit-safe handoff . We take a raw number whose name tells us it was in meters, and we pass it to the quantity maker for that same unit . We can see this line is unit-correct simply by inspection\u2014our first example of a unit-safe line. In fact, we have already achieved unit safety everywhere we use the quantity track_length instead of the raw number track_length_m ! Think of the quantity as a container , which holds its value securely together with information about its unit. We\u2019ll see that the quantity prevents us from using that value in ways that are incompatible with its unit. Retrieving values: you must name the unit \u00b6 Ideally, every interface that takes physical quantities would use unit-safe quantity types . In practice, you can\u2019t upgrade your entire codebase at once. Even if you could, there will always be third-party libraries which don\u2019t know about these quantity types. One way or another, it\u2019s important to be able to get the value out. Let\u2019s imagine we have this example third-party API, which needs a raw double . How can we call it if we have a quantity? // Example third-party API. class Racetrack ; class RacetrackBuilder { public : // Main function we'll call: void set_length_m ( double length_m ); Racetrack build_track (); }; Most units libraries provide a function that retrieves a quantity\u2019s value \u201cin whatever units it happens to be stored\u201d. (Think of std::chrono::duration::count() as a very common example.) These kinds of functions may be convenient, but they\u2019re not unit-safe. 1 Au takes a different approach. To retrieve the value from a quantity q , you call q.in(units) , where units is the quantity maker you used to store the value. Continuing with our earlier example, we could call that API like so: RacetrackBuilder builder ; builder . set_length_m ( track_length . in ( meters )) // ^^ ^^^^^^^^^^^ // API wants length in *meters* Get value in *meters* Here, we have another unit-safe handoff . Our first one showed how we enter the library by naming the unit. This one shows how we exit the library by naming that same unit. Tip Think of the quantity maker\u2019s name as a kind of \u201cpassword\u201d which you set when you create the quantity. The quantity will hold its underlying value securely. To retrieve that value, you must speak the same \u201cpassword\u201d (that is, name the same unit). Of course, this API is a best-case scenario for raw numeric APIs, since it names the units at the callsite (via the _m suffix on set_length_m() ). Our other API, average_speed_mps() , can\u2019t do this, because we can\u2019t see the parameter names at the callsite. In fact, although we\u2019ll see some coping strategies in later lessons, there is no unit-safe way to call average_speed_mps() directly . Basic quantity operations \u00b6 Quantity types do much more than simply hold their values securely: they support a variety of operations. In fact, we strive to support every meaningful operation, because operation implementations for quantity types can faithfully maintain unit safety. Tip Treat any instance of retrieving the value as \u201ccode smell\u201d. Stop and check whether there\u2019s some way to perform the operation within the quantity type. If there\u2019s not, stop and consider whether there should be. By \u201ccode smell\u201d, we don\u2019t mean that it\u2019s definitely wrong; in fact, it\u2019s often necessary. We just mean it\u2019s worth checking to see if there\u2019s a better pattern. The first and most basic operations which we\u2019ll cover here are arithmetic operations. You can add, subtract, and compare quantities of the same units. 2 You can multiply and divide quantities of any units. Example: same-unit operations Here are a couple examples of operations among quantities with the same unit . constexpr auto distance = meters ( 1.0 ) + meters ( 2.0 ) // distance -> meters(3.0) constexpr auto is_duration_greater = ( seconds ( 60 ) > seconds ( 55 )); // is_duration_greater -> true Admittedly, these examples are very basic for now. Future lessons will explore more interesting examples\u2014like, what happens when you compare a length in inches, to a length in centimeters? But for now, the takeaway is simply that we neither need nor want to extract underlying values to perform basic operations. Multiplying and dividing quantities \u00b6 The product of two quantities is another quantity. Recall that a quantity variable has two parts: the unit , and the value . These parts compose nicely with multiplication. The unit of the product is the product of the units. The value of the product is the product of the values. All of these same considerations apply to division. So for example: (meters / second) is a quantity maker. You can call it and pass any numerical type, just as with the quantity makers meters or seconds . In particular, meters ( 50.0 ) / seconds ( 10.0 ) == ( meters / second )( 5.0 ); Tip To form a compound quantity maker, use the grammatically correct name of the unit. Examples: meters / second , not meters / seconds newton * meters , not newtons * meters Empirically, we have found that this pattern works: (s * ...) * p / (s * ...) . That is: pluralize only one token for singular tokens: put those which multiply on the left , and those which divide on the right . Exercise: computing with quantities \u00b6 To get some practice with quantities, we\u2019ve included an exercise where you can make and print some quantities, and then upgrade an existing function implementation from raw numbers to quantities. Check out the Au 101: API Types Exercise ! Takeaways \u00b6 We strive for unit safety . If we can check the unit-correctness of every individual line of code, by inspection, in isolation, we can reduce cognitive load, and write code faster and more robustly. To store a raw numeric value safely inside of a quantity object, call the quantity maker whose name is the unit of interest. For example, meters(3) is quantity representing 3\\,\\text{m} 3\\,\\text{m} , stored as int . To retrieve a stored numeric value from a quantity q , call q.in(units) , where units was the quantity maker used in the first place. For example, meters(3).in(meters) is simply 3 . Quantity makers compose : you can multiply, divide, and raise them to powers to get a new quantity maker. For example, (meters / second) is a quantity maker which you can call like any other. (meters / second)(5) represents the quantity 5\\,\\text{m/s} 5\\,\\text{m/s} . Tip Au only contains unit-safe interfaces. That\u2019s why simply storing the value in a quantity is enough to achieve unit-safety! To take the example from std::chrono::duration , note that the system clock has different resolutions on different widely used toolchains . gcc uses 1\\,\\text{ns} 1\\,\\text{ns} , MSVC uses 100\\,\\text{ns} 100\\,\\text{ns} , and clang uses 1000\\,\\text{ns} 1000\\,\\text{ns} . So if you subtracted two calls to std::chrono::system_clock::now() and called .count() , your answers would vary by 3 orders of magnitude on different compilers! This is not to say that doing so would be a good use of the chrono library. It\u2019s not, and that\u2019s the point: a bare call to .count() gives the reader no idea how to interpret its result. \u21a9 What about adding, subtracting, and comparing quantities of different units, but the same dimensions\u2014like comparing seconds(100) to minutes(1) , or adding inches(1) to feet(6) ? In most cases, we do support this as well, but it\u2019s a more advanced usage which we\u2019ll discuss further in future lessons. \u21a9","title":"Au 101: Quantity Makers"},{"location":"tutorial/101-quantity-makers/#au-101-quantity-makers","text":"This tutorial gives a gentle introduction to the Au library. Time: TBD. Prerequisites: Experience writing C++ code. You will learn: The concept and importance of \u201cunit safety\u201d. How to store a numeric value in a quantity . How to retrieve the stored numeric value. Some basic operations you can perform with a quantity.","title":"Au 101: Quantity Makers"},{"location":"tutorial/101-quantity-makers/#status-quo-no-units-library","text":"Suppose you have a variable that represents a physical quantity . That variable has some value , but that value is meaningless unless you also know the unit of measurement . We usually indicate the unit with a suffix on the variable name. Here\u2019s a concrete example: const double track_length_m = 100.0 ; // Unit suffix--^^ ^^^^^--Value const double best_time_s = 10.34 ; // Unit suffix--^^ ^^^^^--Value The first value is 100.0 . Since there\u2019s no such thing as a \u201clength of 100\u201d, we add a _m suffix on the end of our variable name to make it clear that the value is the length in meters . We take a similar approach for our time in seconds . This strategy works , in the sense that it can prevent unit errors, but it\u2019s labor intensive and error prone. Consider a function we might want to call: double average_speed_mps ( double length_m , double time_s ); With the above variables, our callsite might look like this: const auto speed_mps = average_speed_mps ( track_length_m , best_time_s ); It\u2019s time to consider a very important property: Definition Unit correctness: a program is unit-correct when every variable associated with physical units is used consistently with those units. So: is this unit-correct? Yes: track_length_m gets passed as the parameter length_m : meters to meters best_time_s gets passed as the parameter time_s : seconds to seconds However, it\u2019s quite fragile. We could just as easily have written the following. const auto speed_mps = average_speed_mps ( best_time_s , track_length_m ); By itself, this line looks correct: we\u2019re asking for an average speed, given a time and a length. We can even see that we\u2019re passing in values in seconds and meters to get a result in meters-per-second, increasing our confidence! Of course, the line is wrong, but the only way to know that it\u2019s wrong is to go read the declaration of average_speed_mps . This could easily be in some other file. In a big project, it might be hard to even figure out which file it\u2019s in. That\u2019s a lot of cognitive load!","title":"Status quo: no units library"},{"location":"tutorial/101-quantity-makers/#our-goal-unit-safety","text":"To write code quickly and robustly, unit-correctness is not enough . We need more: we need unit safety . Definition Unit safety : We call a program unit-safe when the unit-correctness of each line of code can be checked by inspection , in isolation . This is the way to reduce cognitive load for code readers, when it comes to physical units. If you inspect a unit-safe line, and see that it\u2019s correct, then you\u2019re done with that line. You can move on; you don\u2019t have to hold it in your head. Tip A unit-safe line doesn\u2019t guarantee that the program has no unit errors. It does guarantee that if there are unit errors, then they\u2019re in some other line (which you can also inspect!). Unit-safety is not something you could ever get from the standard numeric types, but you can get it from the Au library. Let\u2019s learn how!","title":"Our goal: unit safety"},{"location":"tutorial/101-quantity-makers/#storing-values-the-quantity-maker","text":"The way to achieve unit-safety is by turning our raw numeric values into quantities . We do this with quantity makers . These are callables\u2014things that act like functions\u2014which have the name of some unit , and accept any numeric type . For example, let\u2019s make our variable track_length_m unit-safe by using the quantity maker, meters : const auto track_length = meters ( track_length_m ); // ^^^^^^ ^^ // Quantity maker of *meters* Takes value in *meters* This is an example of a unit-safe handoff . We take a raw number whose name tells us it was in meters, and we pass it to the quantity maker for that same unit . We can see this line is unit-correct simply by inspection\u2014our first example of a unit-safe line. In fact, we have already achieved unit safety everywhere we use the quantity track_length instead of the raw number track_length_m ! Think of the quantity as a container , which holds its value securely together with information about its unit. We\u2019ll see that the quantity prevents us from using that value in ways that are incompatible with its unit.","title":"Storing values: the \"quantity maker\""},{"location":"tutorial/101-quantity-makers/#retrieving-values-you-must-name-the-unit","text":"Ideally, every interface that takes physical quantities would use unit-safe quantity types . In practice, you can\u2019t upgrade your entire codebase at once. Even if you could, there will always be third-party libraries which don\u2019t know about these quantity types. One way or another, it\u2019s important to be able to get the value out. Let\u2019s imagine we have this example third-party API, which needs a raw double . How can we call it if we have a quantity? // Example third-party API. class Racetrack ; class RacetrackBuilder { public : // Main function we'll call: void set_length_m ( double length_m ); Racetrack build_track (); }; Most units libraries provide a function that retrieves a quantity\u2019s value \u201cin whatever units it happens to be stored\u201d. (Think of std::chrono::duration::count() as a very common example.) These kinds of functions may be convenient, but they\u2019re not unit-safe. 1 Au takes a different approach. To retrieve the value from a quantity q , you call q.in(units) , where units is the quantity maker you used to store the value. Continuing with our earlier example, we could call that API like so: RacetrackBuilder builder ; builder . set_length_m ( track_length . in ( meters )) // ^^ ^^^^^^^^^^^ // API wants length in *meters* Get value in *meters* Here, we have another unit-safe handoff . Our first one showed how we enter the library by naming the unit. This one shows how we exit the library by naming that same unit. Tip Think of the quantity maker\u2019s name as a kind of \u201cpassword\u201d which you set when you create the quantity. The quantity will hold its underlying value securely. To retrieve that value, you must speak the same \u201cpassword\u201d (that is, name the same unit). Of course, this API is a best-case scenario for raw numeric APIs, since it names the units at the callsite (via the _m suffix on set_length_m() ). Our other API, average_speed_mps() , can\u2019t do this, because we can\u2019t see the parameter names at the callsite. In fact, although we\u2019ll see some coping strategies in later lessons, there is no unit-safe way to call average_speed_mps() directly .","title":"Retrieving values: you must name the unit"},{"location":"tutorial/101-quantity-makers/#basic-quantity-operations","text":"Quantity types do much more than simply hold their values securely: they support a variety of operations. In fact, we strive to support every meaningful operation, because operation implementations for quantity types can faithfully maintain unit safety. Tip Treat any instance of retrieving the value as \u201ccode smell\u201d. Stop and check whether there\u2019s some way to perform the operation within the quantity type. If there\u2019s not, stop and consider whether there should be. By \u201ccode smell\u201d, we don\u2019t mean that it\u2019s definitely wrong; in fact, it\u2019s often necessary. We just mean it\u2019s worth checking to see if there\u2019s a better pattern. The first and most basic operations which we\u2019ll cover here are arithmetic operations. You can add, subtract, and compare quantities of the same units. 2 You can multiply and divide quantities of any units. Example: same-unit operations Here are a couple examples of operations among quantities with the same unit . constexpr auto distance = meters ( 1.0 ) + meters ( 2.0 ) // distance -> meters(3.0) constexpr auto is_duration_greater = ( seconds ( 60 ) > seconds ( 55 )); // is_duration_greater -> true Admittedly, these examples are very basic for now. Future lessons will explore more interesting examples\u2014like, what happens when you compare a length in inches, to a length in centimeters? But for now, the takeaway is simply that we neither need nor want to extract underlying values to perform basic operations.","title":"Basic quantity operations"},{"location":"tutorial/101-quantity-makers/#multiplying-and-dividing-quantities","text":"The product of two quantities is another quantity. Recall that a quantity variable has two parts: the unit , and the value . These parts compose nicely with multiplication. The unit of the product is the product of the units. The value of the product is the product of the values. All of these same considerations apply to division. So for example: (meters / second) is a quantity maker. You can call it and pass any numerical type, just as with the quantity makers meters or seconds . In particular, meters ( 50.0 ) / seconds ( 10.0 ) == ( meters / second )( 5.0 ); Tip To form a compound quantity maker, use the grammatically correct name of the unit. Examples: meters / second , not meters / seconds newton * meters , not newtons * meters Empirically, we have found that this pattern works: (s * ...) * p / (s * ...) . That is: pluralize only one token for singular tokens: put those which multiply on the left , and those which divide on the right .","title":"Multiplying and dividing quantities"},{"location":"tutorial/101-quantity-makers/#exercise-computing-with-quantities","text":"To get some practice with quantities, we\u2019ve included an exercise where you can make and print some quantities, and then upgrade an existing function implementation from raw numbers to quantities. Check out the Au 101: API Types Exercise !","title":"Exercise: computing with quantities"},{"location":"tutorial/101-quantity-makers/#takeaways","text":"We strive for unit safety . If we can check the unit-correctness of every individual line of code, by inspection, in isolation, we can reduce cognitive load, and write code faster and more robustly. To store a raw numeric value safely inside of a quantity object, call the quantity maker whose name is the unit of interest. For example, meters(3) is quantity representing 3\\,\\text{m} 3\\,\\text{m} , stored as int . To retrieve a stored numeric value from a quantity q , call q.in(units) , where units was the quantity maker used in the first place. For example, meters(3).in(meters) is simply 3 . Quantity makers compose : you can multiply, divide, and raise them to powers to get a new quantity maker. For example, (meters / second) is a quantity maker which you can call like any other. (meters / second)(5) represents the quantity 5\\,\\text{m/s} 5\\,\\text{m/s} . Tip Au only contains unit-safe interfaces. That\u2019s why simply storing the value in a quantity is enough to achieve unit-safety! To take the example from std::chrono::duration , note that the system clock has different resolutions on different widely used toolchains . gcc uses 1\\,\\text{ns} 1\\,\\text{ns} , MSVC uses 100\\,\\text{ns} 100\\,\\text{ns} , and clang uses 1000\\,\\text{ns} 1000\\,\\text{ns} . So if you subtracted two calls to std::chrono::system_clock::now() and called .count() , your answers would vary by 3 orders of magnitude on different compilers! This is not to say that doing so would be a good use of the chrono library. It\u2019s not, and that\u2019s the point: a bare call to .count() gives the reader no idea how to interpret its result. \u21a9 What about adding, subtracting, and comparing quantities of different units, but the same dimensions\u2014like comparing seconds(100) to minutes(1) , or adding inches(1) to feet(6) ? In most cases, we do support this as well, but it\u2019s a more advanced usage which we\u2019ll discuss further in future lessons. \u21a9","title":"Takeaways"},{"location":"tutorial/exercise/101-quantity-makers/","text":"Au 101: Quantity Makers Exercise \u00b6 Note This is the exercise for the concepts in the tutorial page Au 101: Quantity Makers . We\u2019ll assume you\u2019re familiar with everything in that page, so if you\u2019re not, you\u2019ll want to read it first. TODO: Make a \u201cdevelopment setup\u201d page; link to it from here. Introduction \u00b6 The point of this exercise is to get some practice making and using quantities. We\u2019ll get values into and out of the units library, and we\u2019ll also perform a few operations (simple arithmetic, and streaming output). The file we\u2019ll be working in can be found here, relative to the repository root: \"tutorial/101_quantity_makers.cc\" The following command executes the code: bazel run //tutorial:101_quantity_makers Run it now to make sure everything\u2019s working: it should run to completion, and all tests should pass. Exercise 1: printing quantities \u00b6 Open up the file, \"tutorial/101_quantity_makers.cc\" , and scroll down to the EXERCISE 1(a) section. This takes you to a function, print_raw_number_and_quantity() , where you\u2019ll begin the exercise. Exercise 1(a) Task Solution and Discussion Read through the function print_raw_number_and_quantity() , and uncomment the final two lines. Note that in the second line, we\u2019re streaming a quantity variable to output. What do you expect to see? When you\u2019ve formed an expectation, run the target: bazel run //tutorial:101_quantity_makers What do you see? Did it match your expectations? Here\u2019s what will be printed: track_length_m: 100 track_length: 100 m Note how the unit information has effectively migrated. With the raw double , it was a suffix on the variable name, which means that human readers are responsible for keeping track of it. With the quantity, it becomes a part of the type itself, so the compiler is responsible for keeping track of it. The Au library has a compile-time label for every unit. When we stream the quantity, we first stream its underlying value, and then stream the unit label. Now we have a more interactive example. We\u2019ll create several quantities, and for each one, you need to write how you expect it to be printed. Exercise 1(b) Task Solution and Discussion Scroll down to the PrintsAsExpected test case (just below the EXERCISE 1(b) comment block), and uncomment each test assertion one at a time. Replace the empty string placeholder, \"\" , with the actual string you expect when streaming this quantity. For example, if you see this: EXPECT_EQ ( stream_to_string ( squared ( meters )( 100 )), \"\" ); then you would replace it with this: EXPECT_EQ ( stream_to_string ( squared ( meters )( 100 )), \"100 m^2\" ); When you\u2019re done, your assertions should look something like this: EXPECT_EQ ( stream_to_string ( meters ( 100 )), \"100 m\" ); EXPECT_EQ ( stream_to_string ( meters ( 100.0 ) / seconds ( 8.0 )), \"12.5 m / s\" ); EXPECT_EQ ( stream_to_string (( meters / second )( 12.5 )), \"12.5 m / s\" ); EXPECT_EQ ( stream_to_string (( meters / second )( 10.0 ) / seconds ( 8.0 )), \"1.25 m / s^2\" ); EXPECT_EQ ( stream_to_string (( meters / second )( 10.0 ) * seconds ( 8.0 )), \"80 m\" ); The first is a warm-up problem: a checkpoint to make sure you\u2019re doing the exercise correctly. The second gives an example of a general principle: when we multiply or divide quantities, we can reason independently about the units, and the underlying values. In this case, we know that the result\u2019s underlying value will be 100.0 / 8.0 , that is, 12.5 . And the unit will be meters ( \\text{m} \\text{m} ) divided by seconds ( \\text{s} \\text{s} ), that is, \\text{m} / \\text{s} \\text{m} / \\text{s} . (Notice how the library automatically generates a label for compound units: from the input labels m and s , the compound label m / s is generated at compile time.) The third example represents the same quantity as the second, except that it\u2019s constructed directly via the compound quantity maker , (meters / second) . Again, as in the tutorial page, note the grammar: we write (meters / second) , not (meters / seconds) . The fourth example shows that when we accumulate powers of the same unit, the automatically generated label knows how to represent these. \u201cMeters per second\u201d, divided by \u201cseconds\u201d, gives \u201cmeters per squared second\u201d, labeled as m / s^2 . The fifth example shows that when any unit cancels out completely, it gets dropped from the label. \u201cMeters per second\u201d, times \u201cseconds\u201d, gives simply \u201cmeters\u201d. Exercise 2: implementing with quantities \u00b6 Exercise 2 Task Solution and Discussion Replace the implementation of the function stopping_accel_mpss() with quantities, instead of raw double s. You will probably want to do this in three stages. Create a new quantity variable for each parameter. It should have the same name, minus the unit suffix. For example, for a parameter double duration_s , you would write: const auto duration = seconds ( duration_s ); (Note the unit-safe handoff, between the quantity-maker seconds and the unit suffix _s .) Replace the raw double s in the core computation with their corresponding quantity variables. Note that you\u2019ll need to change both the type (to auto ), and the name (to eliminate the suffix). Use .in(...) to extract the raw double to return. You\u2019ll need to form the correct quantity maker to pass to it. When you\u2019re done, your implementation should look something like this: // Example updated solution: double stopping_accel_mpss ( double initial_speed_mps , double stopping_distance_m ) { const auto initial_speed = ( meters / second )( initial_speed_mps ); const auto stopping_distance = meters ( stopping_distance_m ); const auto accel = - ( initial_speed * initial_speed ) / ( 2.0 * stopping_distance ); return accel . in ( meters / squared ( second )); } Let\u2019s evaluate the code change relative to the original, which we\u2019ll reproduce here for convenience. // Original: double stopping_accel_mpss ( double initial_speed_mps , double stopping_distance_m ) { const double accel_mpss = - ( initial_speed_mps * initial_speed_mps ) / ( 2.0 * stopping_distance_m ); return accel_mpss ; } PRO: The core computation is now protected from unit errors. The core computation is also less cluttered without the unit suffixes. The runtime performance is identical, with even the slightest optimization levels enabled. CON: We\u2019ve added extra lines to turn our double variables into quantities. We haven\u2019t improved unit safety at the callsites at all. Admittedly, this change is pretty marginal for such a short function, but keep in mind that this example is just a baby step. The real power of the library will come when we learn how to use quantities in our API types : our function parameters, return values, and member variables. Then we\u2019ll gain far-reaching improvements that can make development faster and safer across an entire codebase. Summary \u00b6 This exercise showed the basics of how to work with quantities. Here are some skills we practiced: Turning a raw numeric value into a quantity, by calling a quantity maker (for example, meters(5.0) ). Extracting raw numeric values from quantities, by calling .in(...) (for example, accel.in(meters / squared(second)) ). Forming and using compound quantity makers, such as (meters / second)(12.5) . Performing basic operations with quantities, including: Multiplying and dividing them. Streaming them to output (but see the note below). Note I/O streaming support isn\u2019t included in every installation method . For single-file installations, it\u2019s included by default, but can be omitted by choice. For full library installations, one needs to include \"au/io.hh\" to get this functionality. The gist is that it will tend to be either already included, or easily accessible, unless somebody made a conscious decision during the installation to exclude it. Return to the main tutorial page .","title":"Au 101: Quantity Makers Exercise"},{"location":"tutorial/exercise/101-quantity-makers/#au-101-quantity-makers-exercise","text":"Note This is the exercise for the concepts in the tutorial page Au 101: Quantity Makers . We\u2019ll assume you\u2019re familiar with everything in that page, so if you\u2019re not, you\u2019ll want to read it first. TODO: Make a \u201cdevelopment setup\u201d page; link to it from here.","title":"Au 101: Quantity Makers Exercise"},{"location":"tutorial/exercise/101-quantity-makers/#introduction","text":"The point of this exercise is to get some practice making and using quantities. We\u2019ll get values into and out of the units library, and we\u2019ll also perform a few operations (simple arithmetic, and streaming output). The file we\u2019ll be working in can be found here, relative to the repository root: \"tutorial/101_quantity_makers.cc\" The following command executes the code: bazel run //tutorial:101_quantity_makers Run it now to make sure everything\u2019s working: it should run to completion, and all tests should pass.","title":"Introduction"},{"location":"tutorial/exercise/101-quantity-makers/#exercise-1-printing-quantities","text":"Open up the file, \"tutorial/101_quantity_makers.cc\" , and scroll down to the EXERCISE 1(a) section. This takes you to a function, print_raw_number_and_quantity() , where you\u2019ll begin the exercise. Exercise 1(a) Task Solution and Discussion Read through the function print_raw_number_and_quantity() , and uncomment the final two lines. Note that in the second line, we\u2019re streaming a quantity variable to output. What do you expect to see? When you\u2019ve formed an expectation, run the target: bazel run //tutorial:101_quantity_makers What do you see? Did it match your expectations? Here\u2019s what will be printed: track_length_m: 100 track_length: 100 m Note how the unit information has effectively migrated. With the raw double , it was a suffix on the variable name, which means that human readers are responsible for keeping track of it. With the quantity, it becomes a part of the type itself, so the compiler is responsible for keeping track of it. The Au library has a compile-time label for every unit. When we stream the quantity, we first stream its underlying value, and then stream the unit label. Now we have a more interactive example. We\u2019ll create several quantities, and for each one, you need to write how you expect it to be printed. Exercise 1(b) Task Solution and Discussion Scroll down to the PrintsAsExpected test case (just below the EXERCISE 1(b) comment block), and uncomment each test assertion one at a time. Replace the empty string placeholder, \"\" , with the actual string you expect when streaming this quantity. For example, if you see this: EXPECT_EQ ( stream_to_string ( squared ( meters )( 100 )), \"\" ); then you would replace it with this: EXPECT_EQ ( stream_to_string ( squared ( meters )( 100 )), \"100 m^2\" ); When you\u2019re done, your assertions should look something like this: EXPECT_EQ ( stream_to_string ( meters ( 100 )), \"100 m\" ); EXPECT_EQ ( stream_to_string ( meters ( 100.0 ) / seconds ( 8.0 )), \"12.5 m / s\" ); EXPECT_EQ ( stream_to_string (( meters / second )( 12.5 )), \"12.5 m / s\" ); EXPECT_EQ ( stream_to_string (( meters / second )( 10.0 ) / seconds ( 8.0 )), \"1.25 m / s^2\" ); EXPECT_EQ ( stream_to_string (( meters / second )( 10.0 ) * seconds ( 8.0 )), \"80 m\" ); The first is a warm-up problem: a checkpoint to make sure you\u2019re doing the exercise correctly. The second gives an example of a general principle: when we multiply or divide quantities, we can reason independently about the units, and the underlying values. In this case, we know that the result\u2019s underlying value will be 100.0 / 8.0 , that is, 12.5 . And the unit will be meters ( \\text{m} \\text{m} ) divided by seconds ( \\text{s} \\text{s} ), that is, \\text{m} / \\text{s} \\text{m} / \\text{s} . (Notice how the library automatically generates a label for compound units: from the input labels m and s , the compound label m / s is generated at compile time.) The third example represents the same quantity as the second, except that it\u2019s constructed directly via the compound quantity maker , (meters / second) . Again, as in the tutorial page, note the grammar: we write (meters / second) , not (meters / seconds) . The fourth example shows that when we accumulate powers of the same unit, the automatically generated label knows how to represent these. \u201cMeters per second\u201d, divided by \u201cseconds\u201d, gives \u201cmeters per squared second\u201d, labeled as m / s^2 . The fifth example shows that when any unit cancels out completely, it gets dropped from the label. \u201cMeters per second\u201d, times \u201cseconds\u201d, gives simply \u201cmeters\u201d.","title":"Exercise 1: printing quantities"},{"location":"tutorial/exercise/101-quantity-makers/#exercise-2-implementing-with-quantities","text":"Exercise 2 Task Solution and Discussion Replace the implementation of the function stopping_accel_mpss() with quantities, instead of raw double s. You will probably want to do this in three stages. Create a new quantity variable for each parameter. It should have the same name, minus the unit suffix. For example, for a parameter double duration_s , you would write: const auto duration = seconds ( duration_s ); (Note the unit-safe handoff, between the quantity-maker seconds and the unit suffix _s .) Replace the raw double s in the core computation with their corresponding quantity variables. Note that you\u2019ll need to change both the type (to auto ), and the name (to eliminate the suffix). Use .in(...) to extract the raw double to return. You\u2019ll need to form the correct quantity maker to pass to it. When you\u2019re done, your implementation should look something like this: // Example updated solution: double stopping_accel_mpss ( double initial_speed_mps , double stopping_distance_m ) { const auto initial_speed = ( meters / second )( initial_speed_mps ); const auto stopping_distance = meters ( stopping_distance_m ); const auto accel = - ( initial_speed * initial_speed ) / ( 2.0 * stopping_distance ); return accel . in ( meters / squared ( second )); } Let\u2019s evaluate the code change relative to the original, which we\u2019ll reproduce here for convenience. // Original: double stopping_accel_mpss ( double initial_speed_mps , double stopping_distance_m ) { const double accel_mpss = - ( initial_speed_mps * initial_speed_mps ) / ( 2.0 * stopping_distance_m ); return accel_mpss ; } PRO: The core computation is now protected from unit errors. The core computation is also less cluttered without the unit suffixes. The runtime performance is identical, with even the slightest optimization levels enabled. CON: We\u2019ve added extra lines to turn our double variables into quantities. We haven\u2019t improved unit safety at the callsites at all. Admittedly, this change is pretty marginal for such a short function, but keep in mind that this example is just a baby step. The real power of the library will come when we learn how to use quantities in our API types : our function parameters, return values, and member variables. Then we\u2019ll gain far-reaching improvements that can make development faster and safer across an entire codebase.","title":"Exercise 2: implementing with quantities"},{"location":"tutorial/exercise/101-quantity-makers/#summary","text":"This exercise showed the basics of how to work with quantities. Here are some skills we practiced: Turning a raw numeric value into a quantity, by calling a quantity maker (for example, meters(5.0) ). Extracting raw numeric values from quantities, by calling .in(...) (for example, accel.in(meters / squared(second)) ). Forming and using compound quantity makers, such as (meters / second)(12.5) . Performing basic operations with quantities, including: Multiplying and dividing them. Streaming them to output (but see the note below). Note I/O streaming support isn\u2019t included in every installation method . For single-file installations, it\u2019s included by default, but can be omitted by choice. For full library installations, one needs to include \"au/io.hh\" to get this functionality. The gist is that it will tend to be either already included, or easily accessible, unless somebody made a conscious decision during the installation to exclude it. Return to the main tutorial page .","title":"Summary"}]}