{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"au : a C++ units library, by Aurora \u00b6 This will be the main page for the documentation website in the future. For now, let's double check a few features to make sure they work. Feature tests \u00b6 Tabs \u00b6 Tab A Tab B Contents of tab A. Contents of tab A. Can include code blocks: int main ( int argc , char ** argv ) { return 0 ; } \\LaTeX \\LaTeX math \u00b6 Inline: x = x_0 + v_0 t + \\frac{1}{2} a t^2 x = x_0 + v_0 t + \\frac{1}{2} a t^2 . Block: e_i e_j + e_j e_i = \\delta_{ij} e_i e_j + e_j e_i = \\delta_{ij} Emoji \u00b6 Admonitions \u00b6 Warning Be careful!","title":"`au`: a C++ units library, by Aurora"},{"location":"#au-a-c-units-library-by-aurora","text":"This will be the main page for the documentation website in the future. For now, let's double check a few features to make sure they work.","title":"au: a C++ units library, by Aurora"},{"location":"#feature-tests","text":"","title":"Feature tests"},{"location":"#tabs","text":"Tab A Tab B Contents of tab A. Contents of tab A. Can include code blocks: int main ( int argc , char ** argv ) { return 0 ; }","title":"Tabs"},{"location":"#latexlatex-math","text":"Inline: x = x_0 + v_0 t + \\frac{1}{2} a t^2 x = x_0 + v_0 t + \\frac{1}{2} a t^2 . Block: e_i e_j + e_j e_i = \\delta_{ij} e_i e_j + e_j e_i = \\delta_{ij}","title":"\\LaTeX\\LaTeX math"},{"location":"#emoji","text":"","title":"Emoji"},{"location":"#admonitions","text":"Warning Be careful!","title":"Admonitions"},{"location":"develop/","text":"Development Setup \u00b6 This page explains how to set up the repository for development. This is for two main groups of users: Those who want to contribute to the library, either the code or the docs. Those who want to work through the tutorial exercises . Tip If all you want to do is install the library in your project, you can simply use our installation guide . Core development setup \u00b6 These steps are common to all workflows. Step 0: Decide whether to fork \u00b6 If you're confident that you want to contribute , you should start out by forking the repository. This gives you your own copy which you can modify, and from which you can create pull requests to share your changes with the main repository. Here are GitHub's instructions for forking . Everyone else can simply skip this step and work directly from the main repository. If you decide later on to make a pull request, you'll still need to create a fork, but it's easy to set it up after the fact. We'll provide detailed instructions below. Instructions for switching an existing clone to a fork If you're here, you probably cloned the main repository directly, and then later decided to make a pull request. For that, you'll need to switch your origin remote to point to your fork instead of the main repository. You can directly use the instructions below, which we adapted from this guide . TODO We need to try these instructions, in detail, to make sure they work. Somebody should create a PR to remove this warning---and do so from a clone which was originally tracking the main repository, but which transitioned to a fork by following these very instructions. Create the fork on GitHub. You will need to note the name of your fork, in the format user_name/repo_name . Typically, the user_name part will be replaced with your GitHub username, and the repo_name part will simply be au . Rename origin to upstream . We still want to track the main repository; we just need to give it a different name. Run this command verbatim: git remote rename origin upstream Make your fork the new origin . Your command will start with git remote add origin , and end with a URL for your repository. If your GitHub username were user_name , the full command should look like this: git remote add origin git@github.com:user_name/au.git # ^^^^^^^^^ # Example only: remember to replace user name! Fetch from origin . Run this command verbatim: git fetch origin Track origin from main . Run this command verbatim: git branch -u origin/main main At this point, you should be able to create a pull request in the usual way, simply by pushing a local branch to your fork via the origin remote. Step 1: Clone the repository \u00b6 This step gets the Au source code onto your machine. The precise details depend on whether you decided to fork or not in the previous step. Did you fork, or not? No fork (default) Fork This is for users who just want to work through the tutorials, or play around with the code. git clone https://github.com/aurora-opensource/au.git Follow GitHub's cloning instructions , using the fork you created as the repository. Whichever approach you took, you should have a folder named au/ in your current directory which contains the Au source code. Step 2: Set up direnv \u00b6 direnv is a tool that makes it easy to use the correct version of every tool we use: bazel , clang-format , buildifier , and other project-specific ones like make-single-file and au-docs-serve . It will add these tools to your $PATH , but only when you're inside your copy of the repository. What if you skip this step? This step is optional, but highly recommended. If you skip this step, you'll need to prepend tools/bin/ to every command that comes from Au's tools directory. For example, Replace bazel with tools/bin/bazel . Replace clang-format with tools/bin/clang-format . And so on. The first step to set up direnv is to install the tool itself, using their installation instructions . The next time you enter your Au folder, you'll get a warning message like this: direnv: error .envrc is blocked. Run `direnv allow` to approve its content. Simply do what it says and run direnv allow , and you're all set! Testing your installation You can test that everything's working by running bazel --version inside your Au folder. You should get a result compatible with the current contents of the .bazelversion file. For example, at the time of writing, we're on bazel 5.3.0, so this command produces the output: bazel 5.3.0 Specific workflows \u00b6 Now that your basic development setup is complete, here are some types of workflows you can do. Building and testing the code \u00b6 To build and test the entire repository, run bazel test //...:all . Note The first time you run any command such as bazel , there may be some additional overhead from downloading or configuring the tool itself. This is a one-time cost, and each subsequent run should be fast. You can also specify any number of specific targets or target patterns, using bazel's target syntax . For example, if you wanted to test the core library code (which lives in //au ), and test the generated single-file package (whose target is //release:au_hh_test ), you could write: bazel test //au:all //release:au_hh_test Using different toolchains \u00b6 Au comes pre-packaged with support for several different compiler toolchains. To use a specific toolchain --- say, X --- pass it as a --config=X argument. For example, here's how you would run all of the tests using gcc 10: bazel test --config = gcc10 //...:all Here are the possible values we support for --config : --config value compiler clang14 Clang 14 (default) clang11 Clang 11 gcc10 gcc 10 What if your preferred compiler isn't in this list? Our goal is for Au to work with any standards-compliant compiler that fully supports C++14, or any later language standard. We've had good results with a variety of compilers already, so we recommend simply trying Au in yours! If you do, and you find a bug, please feel free to file an issue. If the compiler is fully C++14-compatible, we'll do our best to find a fix, or an acceptable workaround. We may also consider adding the compiler to our officially supported list, as long as we can use it via a hermetic bazel toolchain. Building and viewing documentation \u00b6 It's easy to set up a local version of the documentation website. Simply run the included command, au-docs-serve . Here's some example output: INFO: Analyzed target //:update_docs (0 packages loaded, 0 targets configured). INFO: Found 1 target... Target //:update_docs up-to-date: bazel-bin/update_docs INFO: Elapsed time: 0.309s, Critical Path: 0.06s INFO: 1 process: 1 internal. INFO: Build completed successfully, 1 total action INFO: Build completed successfully, 1 total action INFO - Building documentation... INFO - Cleaning site directory INFO - Documentation built in 0.35 seconds INFO - [16:02:34] Watching paths for changes: 'docs', 'mkdocs.yml' INFO - [16:02:34] Serving on http://127.0.0.1:8000/au/ The last line shows that you can view the website at the included (local) URL, http://127.0.0.1:8000/au/ . The command stays running until you interrupt it (typically via Ctrl-C , or the equivalent on your terminal ). Note that as long as it stays running, it will automatically regenerate the website whenever you edit any file, and the browser will automatically reload the page! Viewing documentation on a remote machine Some users connect to a remote machine via ssh to do their development. In this case, au-docs-serve won't work out of the box. The reason is that it's running on your remote machine, but your web browser is on your local machine. When you try to open the URL http://127.0.0.1:8000/au/ , which points to the local machine , it can't find the web server, because it's running on the remote machine. The solution is to forward the port, 8000 , when you connect to your remote machine. If you do, then local requests on that port will be forwarded along to the remote machine, where the web server is running. Here's how you do that. Find your usual ssh command. This is whatever you run on your local machine to connect to the remote host. For example, if your username is user and your remote hostname is remote.host , this might look like the following: ssh user@remote.host Add an option for port forwarding. Expanding on the previous example, this would be: ssh -L 8000 :localhost:8000 user@remote.host # ^^^^^^^^^^^^^^^^^^^^^^^ Note: this is added Run au-docs-serve on the remote host. Naturally, you'll need to be in your Au folder to do this. At this point, as long as that command stays running on your remote host, you should be able to visit the URL in your local browser, and view the documentation website.","title":"Development Setup"},{"location":"develop/#development-setup","text":"This page explains how to set up the repository for development. This is for two main groups of users: Those who want to contribute to the library, either the code or the docs. Those who want to work through the tutorial exercises . Tip If all you want to do is install the library in your project, you can simply use our installation guide .","title":"Development Setup"},{"location":"develop/#core-development-setup","text":"These steps are common to all workflows.","title":"Core development setup"},{"location":"develop/#step-0-decide-whether-to-fork","text":"If you're confident that you want to contribute , you should start out by forking the repository. This gives you your own copy which you can modify, and from which you can create pull requests to share your changes with the main repository. Here are GitHub's instructions for forking . Everyone else can simply skip this step and work directly from the main repository. If you decide later on to make a pull request, you'll still need to create a fork, but it's easy to set it up after the fact. We'll provide detailed instructions below. Instructions for switching an existing clone to a fork If you're here, you probably cloned the main repository directly, and then later decided to make a pull request. For that, you'll need to switch your origin remote to point to your fork instead of the main repository. You can directly use the instructions below, which we adapted from this guide . TODO We need to try these instructions, in detail, to make sure they work. Somebody should create a PR to remove this warning---and do so from a clone which was originally tracking the main repository, but which transitioned to a fork by following these very instructions. Create the fork on GitHub. You will need to note the name of your fork, in the format user_name/repo_name . Typically, the user_name part will be replaced with your GitHub username, and the repo_name part will simply be au . Rename origin to upstream . We still want to track the main repository; we just need to give it a different name. Run this command verbatim: git remote rename origin upstream Make your fork the new origin . Your command will start with git remote add origin , and end with a URL for your repository. If your GitHub username were user_name , the full command should look like this: git remote add origin git@github.com:user_name/au.git # ^^^^^^^^^ # Example only: remember to replace user name! Fetch from origin . Run this command verbatim: git fetch origin Track origin from main . Run this command verbatim: git branch -u origin/main main At this point, you should be able to create a pull request in the usual way, simply by pushing a local branch to your fork via the origin remote.","title":"Step 0: Decide whether to fork"},{"location":"develop/#step-1-clone-the-repository","text":"This step gets the Au source code onto your machine. The precise details depend on whether you decided to fork or not in the previous step. Did you fork, or not? No fork (default) Fork This is for users who just want to work through the tutorials, or play around with the code. git clone https://github.com/aurora-opensource/au.git Follow GitHub's cloning instructions , using the fork you created as the repository. Whichever approach you took, you should have a folder named au/ in your current directory which contains the Au source code.","title":"Step 1: Clone the repository"},{"location":"develop/#step-2-set-up-direnv","text":"direnv is a tool that makes it easy to use the correct version of every tool we use: bazel , clang-format , buildifier , and other project-specific ones like make-single-file and au-docs-serve . It will add these tools to your $PATH , but only when you're inside your copy of the repository. What if you skip this step? This step is optional, but highly recommended. If you skip this step, you'll need to prepend tools/bin/ to every command that comes from Au's tools directory. For example, Replace bazel with tools/bin/bazel . Replace clang-format with tools/bin/clang-format . And so on. The first step to set up direnv is to install the tool itself, using their installation instructions . The next time you enter your Au folder, you'll get a warning message like this: direnv: error .envrc is blocked. Run `direnv allow` to approve its content. Simply do what it says and run direnv allow , and you're all set! Testing your installation You can test that everything's working by running bazel --version inside your Au folder. You should get a result compatible with the current contents of the .bazelversion file. For example, at the time of writing, we're on bazel 5.3.0, so this command produces the output: bazel 5.3.0","title":"Step 2: Set up direnv"},{"location":"develop/#specific-workflows","text":"Now that your basic development setup is complete, here are some types of workflows you can do.","title":"Specific workflows"},{"location":"develop/#building-and-testing-the-code","text":"To build and test the entire repository, run bazel test //...:all . Note The first time you run any command such as bazel , there may be some additional overhead from downloading or configuring the tool itself. This is a one-time cost, and each subsequent run should be fast. You can also specify any number of specific targets or target patterns, using bazel's target syntax . For example, if you wanted to test the core library code (which lives in //au ), and test the generated single-file package (whose target is //release:au_hh_test ), you could write: bazel test //au:all //release:au_hh_test","title":"Building and testing the code"},{"location":"develop/#using-different-toolchains","text":"Au comes pre-packaged with support for several different compiler toolchains. To use a specific toolchain --- say, X --- pass it as a --config=X argument. For example, here's how you would run all of the tests using gcc 10: bazel test --config = gcc10 //...:all Here are the possible values we support for --config : --config value compiler clang14 Clang 14 (default) clang11 Clang 11 gcc10 gcc 10 What if your preferred compiler isn't in this list? Our goal is for Au to work with any standards-compliant compiler that fully supports C++14, or any later language standard. We've had good results with a variety of compilers already, so we recommend simply trying Au in yours! If you do, and you find a bug, please feel free to file an issue. If the compiler is fully C++14-compatible, we'll do our best to find a fix, or an acceptable workaround. We may also consider adding the compiler to our officially supported list, as long as we can use it via a hermetic bazel toolchain.","title":"Using different toolchains"},{"location":"develop/#building-and-viewing-documentation","text":"It's easy to set up a local version of the documentation website. Simply run the included command, au-docs-serve . Here's some example output: INFO: Analyzed target //:update_docs (0 packages loaded, 0 targets configured). INFO: Found 1 target... Target //:update_docs up-to-date: bazel-bin/update_docs INFO: Elapsed time: 0.309s, Critical Path: 0.06s INFO: 1 process: 1 internal. INFO: Build completed successfully, 1 total action INFO: Build completed successfully, 1 total action INFO - Building documentation... INFO - Cleaning site directory INFO - Documentation built in 0.35 seconds INFO - [16:02:34] Watching paths for changes: 'docs', 'mkdocs.yml' INFO - [16:02:34] Serving on http://127.0.0.1:8000/au/ The last line shows that you can view the website at the included (local) URL, http://127.0.0.1:8000/au/ . The command stays running until you interrupt it (typically via Ctrl-C , or the equivalent on your terminal ). Note that as long as it stays running, it will automatically regenerate the website whenever you edit any file, and the browser will automatically reload the page! Viewing documentation on a remote machine Some users connect to a remote machine via ssh to do their development. In this case, au-docs-serve won't work out of the box. The reason is that it's running on your remote machine, but your web browser is on your local machine. When you try to open the URL http://127.0.0.1:8000/au/ , which points to the local machine , it can't find the web server, because it's running on the remote machine. The solution is to forward the port, 8000 , when you connect to your remote machine. If you do, then local requests on that port will be forwarded along to the remote machine, where the web server is running. Here's how you do that. Find your usual ssh command. This is whatever you run on your local machine to connect to the remote host. For example, if your username is user and your remote hostname is remote.host , this might look like the following: ssh user@remote.host Add an option for port forwarding. Expanding on the previous example, this would be: ssh -L 8000 :localhost:8000 user@remote.host # ^^^^^^^^^^^^^^^^^^^^^^^ Note: this is added Run au-docs-serve on the remote host. Naturally, you'll need to be in your Au folder to do this. At this point, as long as that command stays running on your remote host, you should be able to visit the URL in your local browser, and view the documentation website.","title":"Building and viewing documentation"},{"location":"install/","text":"Installation \u00b6 Au can be installed in multiple ways. First, we'll help you decide which one is right for you. Then, we'll provide full instructions for each option. Broadly, you can either do a \"full install\" of the library, or you can package it into a single header file. For the latter approach, there are two options: Pre-built versions you can download right away. Custom versions with exactly the units you choose. Choosing a method \u00b6 You should consider several factors before you decide how to install the Au library, such as: Tradeoffs in setup time, unit selection, and flexibility. Whether you're installing for production, or just trying it out. Your build system. Here's an overview of the tradeoffs involved. Legend Unsupported Fair Good Best Single File Full Install Pre-built Custom bazel CMake, conan, vcpkg, ... Setup time ~1 min ~10 min ~10 min Not yet supported (use single-file instead for now) Unit selection Base units only Any units desired Any units desired, without needing \"reinstall\" Compile time cost ~10 units Very competitive up to a few dozen units Each file only pays for the units it uses Flexibility Awkward: would need to download io.hh and/or testing.hh separately, and modify their includes manually Include I/O, testing utilities, individual units as desired, on a per-file basis So, which should you use? graph TD Usage[What's your use case?] SetupTime[Got 10 minutes for setup?] BuildSystem[What's your build system?] UsePreBuilt[Use pre-built single file] UseCustom[Use custom single file] UseFullInstall[Use full install] Usage -->|Just playing around with Au| SetupTime SetupTime -->|No! Just let me start!| UsePreBuilt SetupTime -->|Sure| UseCustom Usage -->|Ready to use in my project!| BuildSystem BuildSystem -->|bazel| UseFullInstall BuildSystem -->|other| UseCustom Installation instructions \u00b6 Here are the instructions for each installation method we support. Single file \u00b6 The Au library can be packaged as a single header file, which you can include in your project just like any other header. This works with any build system! To take this approach, obtain the single file by one of the methods described below. Then, put it inside a third_party folder (for example, as third_party/au.hh ). Now you're up and running with Au! Every single-file package automatically includes the following features: Warning Before public release, we should ensure each of the following items has a documentation page, and link to that page here: Basic \"unit container\" types: Quantity , QuantityPoint Magnitude types and values, including the constant PI , and constants for any integer such as mag<5280>() . All prefixes for SI ( kilo , mega , ...) and informational ( kibi , mebi , ...) quantities. Math functions, including unit-aware rounding and inverses, trigonometric functions, square roots, and so on. Bidirectional implicit conversion between Quantity types and any equivalent counterparts in the std::chrono library. Here are the two ways to get a single-file packaging of the library. Pre-built single file \u00b6 Tip This approach is mainly for playing with the library. It's very fast to get up and running, but it's not the best choice as the \"production\" installation of your library. For a single-file approach, most users will be much better served by the next section, which explains how to customize it to get exactly the units you want. We provide pre-generated single-file versions of the library, automatically generated from the latest commit in the repo: au.hh au_noio.hh (Same as above, but with <iostream> support stripped out) These include very few units (to keep compile times short). However, combinations of these units should get you any other unit you're likely to want. The units we include are: Every SI base unit ( seconds , meters , kilo(grams) , amperes , kelvins , moles , candelas ) Base units for angles and information ( radians , bits ) A base dimensionless unit ( unos ) Note How do you go about constructing other units from these? By composing them. For example, you can make other coherent SI units like this: constexpr auto newtons = kilo ( gram ) * meters / squared ( second ); Now you can call, say, newtons(10) and get a quantity equivalent to 10 Newtons. You can also scale a unit by multiplying by Magnitude objects. For example: constexpr auto degrees = radians * PI / mag < 180 > (); These will \"work\", in the sense of producing correct results. But these ad hoc unit definitions are far less usable than fully defined units . Both the type names and the unit symbols will be needlessly complicated. Again, we recommend following the directions in the next section to get exactly the units you care about. Custom single file \u00b6 It's easy to package the library in a custom single file with exactly the units you need. Here's how: Clone the repo . Go to the aurora-opensource/au repo, and follow the typical instructions. If you're just a user of Au, not a contributor , this should be: git clone https://github.com/aurora-opensource/au.git Run the script . tools/bin/make-single-file --units meters seconds newtons > ~/au.hh creates a file, ~/au.hh , which packages the entire library in a single file with these three units. To see the full list of available units, search the .hh files in the au/units/ folder. For example, meters will include the contents of au/units/meters.hh . Provide the --noio flag if you prefer to avoid the expense of the <iostream> library. Now you have a file, ~/au.hh , which you can add to your third_party folder. Full library installation \u00b6 bazel \u00b6 Warning These instructions were written while the Au repo was still private. Therefore, we couldn't fully test that they actually work . However, when adding a backup file:/// URL pointing to a manually downloaded copy, they did work, which is a very promising sign. Choose your Au version . This can be a tag, or a commit hash. Let's take 0.2.0 as an example. Form the URL to the archive . For 0.2.0 , this would be: https://github.com/aurora-opensource/au/archive/0.2.0.tar.gz NOTE: Your au version ID goes HERE ^^^^^ Compute your SHA256 hash . Follow the URL from the previous step to download the archive. Compute the SHA256 hash: sha256sum au-0.2.0.tar.gz The first token that appears is the hash. Save it for the next step. Add http_archive rule to WORKSPACE . Follow this pattern: http_archive ( name = \"au\" , sha256 = \"bdaec065b35f44af2cb22def5b69ac08ca40c47791ea3ed2eb3ebf3e85b3e0b0\" , strip_prefix = \"au-0.2.0\" , urls = [ \"https://github.com/aurora-opensource/au/archive/0.2.0.tar.gz\" ], ) In particular, here's how to fill out the fields: sha256 : Use the SHA256 hash you got from step 3. strip_prefix : write \"au-0.2.0\" , except use your ID from step 1 instead of 0.2.0 . urls : This should be a list, whose only entry is the URL you formed in step 2. At this point, the Au library is installed, and you can use it in your project! Here are the headers provided by each Au target. To use, add the \"Dependency\" to your deps attribute, and include the appropriate files. Dependency Headers provided Notes @au//au \"au/au.hh\" \"au/units.*.hh\" Core library functionality. See all available units @au//au:io \"au/io.hh\" operator<< support @au//au:testing \"au/testing.hh\" Utilities for testing Note: testonly = True Other build systems (CMake / conan / vcpkg / ...) \u00b6 We would like to support all these build and packaging systems, and perhaps others! But the initial public release is bazel-only, because bazel is what we use at Aurora, and we don't have experience with any of these alternatives. Thus, we'll need to lean on the community to support them. Meanwhile, the library itself is still at least partially available on all build environments, via the single-file options explained above.","title":"Installation"},{"location":"install/#installation","text":"Au can be installed in multiple ways. First, we'll help you decide which one is right for you. Then, we'll provide full instructions for each option. Broadly, you can either do a \"full install\" of the library, or you can package it into a single header file. For the latter approach, there are two options: Pre-built versions you can download right away. Custom versions with exactly the units you choose.","title":"Installation"},{"location":"install/#choosing-a-method","text":"You should consider several factors before you decide how to install the Au library, such as: Tradeoffs in setup time, unit selection, and flexibility. Whether you're installing for production, or just trying it out. Your build system. Here's an overview of the tradeoffs involved. Legend Unsupported Fair Good Best Single File Full Install Pre-built Custom bazel CMake, conan, vcpkg, ... Setup time ~1 min ~10 min ~10 min Not yet supported (use single-file instead for now) Unit selection Base units only Any units desired Any units desired, without needing \"reinstall\" Compile time cost ~10 units Very competitive up to a few dozen units Each file only pays for the units it uses Flexibility Awkward: would need to download io.hh and/or testing.hh separately, and modify their includes manually Include I/O, testing utilities, individual units as desired, on a per-file basis So, which should you use? graph TD Usage[What's your use case?] SetupTime[Got 10 minutes for setup?] BuildSystem[What's your build system?] UsePreBuilt[Use pre-built single file] UseCustom[Use custom single file] UseFullInstall[Use full install] Usage -->|Just playing around with Au| SetupTime SetupTime -->|No! Just let me start!| UsePreBuilt SetupTime -->|Sure| UseCustom Usage -->|Ready to use in my project!| BuildSystem BuildSystem -->|bazel| UseFullInstall BuildSystem -->|other| UseCustom","title":"Choosing a method"},{"location":"install/#installation-instructions","text":"Here are the instructions for each installation method we support.","title":"Installation instructions"},{"location":"install/#single-file","text":"The Au library can be packaged as a single header file, which you can include in your project just like any other header. This works with any build system! To take this approach, obtain the single file by one of the methods described below. Then, put it inside a third_party folder (for example, as third_party/au.hh ). Now you're up and running with Au! Every single-file package automatically includes the following features: Warning Before public release, we should ensure each of the following items has a documentation page, and link to that page here: Basic \"unit container\" types: Quantity , QuantityPoint Magnitude types and values, including the constant PI , and constants for any integer such as mag<5280>() . All prefixes for SI ( kilo , mega , ...) and informational ( kibi , mebi , ...) quantities. Math functions, including unit-aware rounding and inverses, trigonometric functions, square roots, and so on. Bidirectional implicit conversion between Quantity types and any equivalent counterparts in the std::chrono library. Here are the two ways to get a single-file packaging of the library.","title":"Single file"},{"location":"install/#pre-built-single-file","text":"Tip This approach is mainly for playing with the library. It's very fast to get up and running, but it's not the best choice as the \"production\" installation of your library. For a single-file approach, most users will be much better served by the next section, which explains how to customize it to get exactly the units you want. We provide pre-generated single-file versions of the library, automatically generated from the latest commit in the repo: au.hh au_noio.hh (Same as above, but with <iostream> support stripped out) These include very few units (to keep compile times short). However, combinations of these units should get you any other unit you're likely to want. The units we include are: Every SI base unit ( seconds , meters , kilo(grams) , amperes , kelvins , moles , candelas ) Base units for angles and information ( radians , bits ) A base dimensionless unit ( unos ) Note How do you go about constructing other units from these? By composing them. For example, you can make other coherent SI units like this: constexpr auto newtons = kilo ( gram ) * meters / squared ( second ); Now you can call, say, newtons(10) and get a quantity equivalent to 10 Newtons. You can also scale a unit by multiplying by Magnitude objects. For example: constexpr auto degrees = radians * PI / mag < 180 > (); These will \"work\", in the sense of producing correct results. But these ad hoc unit definitions are far less usable than fully defined units . Both the type names and the unit symbols will be needlessly complicated. Again, we recommend following the directions in the next section to get exactly the units you care about.","title":"Pre-built single file"},{"location":"install/#custom-single-file","text":"It's easy to package the library in a custom single file with exactly the units you need. Here's how: Clone the repo . Go to the aurora-opensource/au repo, and follow the typical instructions. If you're just a user of Au, not a contributor , this should be: git clone https://github.com/aurora-opensource/au.git Run the script . tools/bin/make-single-file --units meters seconds newtons > ~/au.hh creates a file, ~/au.hh , which packages the entire library in a single file with these three units. To see the full list of available units, search the .hh files in the au/units/ folder. For example, meters will include the contents of au/units/meters.hh . Provide the --noio flag if you prefer to avoid the expense of the <iostream> library. Now you have a file, ~/au.hh , which you can add to your third_party folder.","title":"Custom single file"},{"location":"install/#full-library-installation","text":"","title":"Full library installation"},{"location":"install/#bazel","text":"Warning These instructions were written while the Au repo was still private. Therefore, we couldn't fully test that they actually work . However, when adding a backup file:/// URL pointing to a manually downloaded copy, they did work, which is a very promising sign. Choose your Au version . This can be a tag, or a commit hash. Let's take 0.2.0 as an example. Form the URL to the archive . For 0.2.0 , this would be: https://github.com/aurora-opensource/au/archive/0.2.0.tar.gz NOTE: Your au version ID goes HERE ^^^^^ Compute your SHA256 hash . Follow the URL from the previous step to download the archive. Compute the SHA256 hash: sha256sum au-0.2.0.tar.gz The first token that appears is the hash. Save it for the next step. Add http_archive rule to WORKSPACE . Follow this pattern: http_archive ( name = \"au\" , sha256 = \"bdaec065b35f44af2cb22def5b69ac08ca40c47791ea3ed2eb3ebf3e85b3e0b0\" , strip_prefix = \"au-0.2.0\" , urls = [ \"https://github.com/aurora-opensource/au/archive/0.2.0.tar.gz\" ], ) In particular, here's how to fill out the fields: sha256 : Use the SHA256 hash you got from step 3. strip_prefix : write \"au-0.2.0\" , except use your ID from step 1 instead of 0.2.0 . urls : This should be a list, whose only entry is the URL you formed in step 2. At this point, the Au library is installed, and you can use it in your project! Here are the headers provided by each Au target. To use, add the \"Dependency\" to your deps attribute, and include the appropriate files. Dependency Headers provided Notes @au//au \"au/au.hh\" \"au/units.*.hh\" Core library functionality. See all available units @au//au:io \"au/io.hh\" operator<< support @au//au:testing \"au/testing.hh\" Utilities for testing Note: testonly = True","title":"bazel"},{"location":"install/#other-build-systems-cmake-conan-vcpkg","text":"We would like to support all these build and packaging systems, and perhaps others! But the initial public release is bazel-only, because bazel is what we use at Aurora, and we don't have experience with any of these alternatives. Thus, we'll need to lean on the community to support them. Meanwhile, the library itself is still at least partially available on all build environments, via the single-file options explained above.","title":"Other build systems (CMake / conan / vcpkg / ...)"},{"location":"troubleshooting/","text":"Troubleshooting Guide \u00b6 This page is a guide to the most commonly encountered types of error, what they mean, and how to fix them. The intended use case is to help you interpret an actual error in your code , at the point where you encounter it. To use this page, copy some relevant snippets from your compiler error, and then search the text of this page using your browser's Find function. Tip To improve your chances of finding what you're looking for, we include full compiler errors from both gcc and clang, inline with the text. Naturally, this makes this page very long, so it's not meant to be read straight through. Stick with your browser's Find function. Each section below lists one category of compiler error you might encounter when using the library. It explains what it means and how to solve it, and gives specific snippets of erroneous code, along with the compiler errors that each would yield. Private constructor \u00b6 Meaning: This means you passed a raw numeric value to an interface that expected a Quantity. It's the \"classic\" error the units library aims to prevent. Solution: Call the appropriate Quantity maker: instead of passing x , pass meters(x) , (kilo(meters) / hour)(x) , etc. A note on quantity makers vs. constructors Every other major units library lets you construct its Quantity types from raw numeric values; it just makes that constructor explicit. Au goes further, and makes this constructor private. The reason is to preserve unit safety at all callsites. We can't know whether you made an alias that doesn't name the unit. For example, if you want everybody to measure lengths in Meters in your codebase, you might provide a common alias like this: using Length = QuantityD < Meters > ; If you did, then end users could write the following: constexpr Length MAX_LENGTH { 5.5 }; // Unsafe! Units unclear. :( A core principle of the Au library is that the only way to enter or exit the library boundaries is to name the unit of measure, explicitly, at the callsite, like this: constexpr Length MAX_LENGTH = meters ( 5.5 ); // Usable! Units unambiguous. :) This enables users who want to use this kind of \"dimension-named alias\" in their codebase to do so safely. Example Code Broken Fixed void set_timeout ( QuantityD < Seconds > dt ); // A (BROKEN): passing raw number where duration expected. set_timeout ( 0.5 ); // B (BROKEN): calling Quantity constructor directly. constexpr QuantityD < Meters > length { 5.5 }; void set_timeout ( QuantityD < Seconds > dt ); // A (FIXED): name the unit. set_timeout ( seconds ( 0.5 )); // B (FIXED): calling Quantity constructor directly. constexpr QuantityD < Meters > length = meters ( 5.5 ); Compiler error (clang 14) au/error_examples.cc:19:17: error: calling a private constructor of class 'au::Quantity<au::Seconds, double>' set_timeout(0.5); ^ ./au/quantity.hh:369:15: note: declared private here constexpr Quantity(Rep value) : value_{value} {} ^ au/error_examples.cc:22:33: error: calling a private constructor of class 'au::Quantity<au::Meters, double>' constexpr QuantityD<Meters> length{5.5}; ^ ./au/quantity.hh:369:15: note: declared private here constexpr Quantity(Rep value) : value_{value} {} ^ Compiler error (clang 11) au/error_examples.cc:19:17: error: calling a private constructor of class 'au::Quantity<au::Seconds, double>' set_timeout(0.5); ^ ./au/quantity.hh:369:15: note: declared private here constexpr Quantity(Rep value) : value_{value} {} ^ au/error_examples.cc:22:33: error: calling a private constructor of class 'au::Quantity<au::Meters, double>' constexpr QuantityD<Meters> length{5.5}; ^ ./au/quantity.hh:369:15: note: declared private here constexpr Quantity(Rep value) : value_{value} {} ^ Compiler error (gcc 10) au/error_examples.cc: In function 'void au::example_private_constructor()': au/error_examples.cc:19:20: error: 'constexpr au::Quantity<UnitT, RepT>::Quantity(au::Quantity<UnitT, RepT>::Rep) [with UnitT = au::Seconds; RepT = double; au::Quantity<UnitT, RepT>::Rep = double]' is private within this context 19 | set_timeout(0.5); | ^ In file included from ./au/math.hh:8, from ./au/au.hh:7, from au/error_examples.cc:1: ./au/quantity.hh:369:15: note: declared private here 369 | constexpr Quantity(Rep value) : value_{value} {} | ^~~~~~~~ au/error_examples.cc:22:43: error: 'constexpr au::Quantity<UnitT, RepT>::Quantity(au::Quantity<UnitT, RepT>::Rep) [with UnitT = au::Meters; RepT = double; au::Quantity<UnitT, RepT>::Rep = double]' is private within this context 22 | constexpr QuantityD<Meters> length{5.5}; | ^ In file included from ./au/math.hh:8, from ./au/au.hh:7, from au/error_examples.cc:1: ./au/quantity.hh:369:15: note: declared private here 369 | constexpr Quantity(Rep value) : value_{value} {} | ^~~~~~~~ Dangerous conversion \u00b6 Meaning: This is a physically meaningful conversion, but we think the risk of a grossly incorrect answer is too high, so we forbid it. There are two main sources for this risk, both having to do with integral storage types. Inexact conversion . Example: inches(24).as(feet) . Overflow . Example: giga(hertz)(1).as(hertz) . Both of these examples would in fact produce the correct answer with the specific values given ( 24 and 1 ). However, many (most!) other values would not. Thus, we disallow the entire conversion operation (at least in this format). Solution: There are different strategies to solve this, depending on your use case. Use floating point . As mentioned above, these risks only apply to integer values. If floating point is what you want anyway, just use it. giga(hertz)(1.0).as(hertz) produces hertz(1'000'000'000.0) . Use \"explicit Rep\" form . The \"Rep\" is the storage type for the Quantity. If you pass it as a template parameter, it is \"morally equivalent\" to a static_cast , and has the same \"forcing\" semantics. inches(24).as<int>(feet) produces feet(2) . Warning Stop and think before using the explicit Rep version. If you're reviewing code that uses it, ask about it. The library is trying to protect you from an error prone operation. The mechanism exists because sometimes you can know that it's OK, but remember to stop and check first! Example Code Broken Fixed (1. Floating Point) Fixed (2. Explicit Rep) // A (BROKEN): inexact conversion. inches ( 24 ). as ( feet ); // B (BROKEN): overflow risk. giga ( hertz )( 1 ). as ( hertz ); // A (FIXED): 1. use floating point. inches ( 24.0 ). as ( feet ); // B (FIXED): 1. use floating point. giga ( hertz )( 1.0 ). as ( hertz ); // A (FIXED): 2. provide explicit Rep. inches ( 24 ). as < int > ( feet ); // B (FIXED): 2. provide explicit Rep. giga ( hertz )( 1 ). as < int > ( hertz ); Compiler error (clang 14) ./au/quantity.hh:147:9: error: static_assert failed due to requirement 'implicit_rep_permitted_from_source_to_target<int>(unit, u)' \"Dangerous conversion: use .as<Rep>(NewUnit) instead\" static_assert(implicit_rep_permitted_from_source_to_target<Rep>(unit, u), ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ./au/quantity.hh:183:16: note: in instantiation of function template specialization 'au::Quantity<au::Inches, int>::as<au::Feet, void>' requested here return as(NewUnit{}); ^ au/error_examples.cc:30:16: note: in instantiation of function template specialization 'au::Quantity<au::Inches, int>::as<au::Feet>' requested here inches(24).as(feet); ^ In file included from au/error_examples.cc:1: In file included from ./au/au.hh:7: In file included from ./au/math.hh:8: ./au/quantity.hh:147:9: error: static_assert failed due to requirement 'implicit_rep_permitted_from_source_to_target<int>(unit, u)' \"Dangerous conversion: use .as<Rep>(NewUnit) instead\" static_assert(implicit_rep_permitted_from_source_to_target<Rep>(unit, u), ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ./au/quantity.hh:183:16: note: in instantiation of function template specialization 'au::Quantity<au::Giga<au::Hertz>, int>::as<au::Hertz, void>' requested here return as(NewUnit{}); ^ au/error_examples.cc:33:20: note: in instantiation of function template specialization 'au::Quantity<au::Giga<au::Hertz>, int>::as<au::Hertz>' requested here giga(hertz)(1).as(hertz); ^ Compiler error (clang 11) ./au/quantity.hh:147:9: error: static_assert failed due to requirement 'implicit_rep_permitted_from_source_to_target<int>(unit, u)' \"Dangerous conversion: use .as<Rep>(NewUnit) instead\" static_assert(implicit_rep_permitted_from_source_to_target<Rep>(unit, u), ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ./au/quantity.hh:183:16: note: in instantiation of function template specialization 'au::Quantity<au::Inches, int>::as<au::Feet, void>' requested here return as(NewUnit{}); ^ au/error_examples.cc:30:16: note: in instantiation of function template specialization 'au::Quantity<au::Inches, int>::as<au::Feet>' requested here inches(24).as(feet); ^ In file included from au/error_examples.cc:1: In file included from ./au/au.hh:7: In file included from ./au/math.hh:8: ./au/quantity.hh:147:9: error: static_assert failed due to requirement 'implicit_rep_permitted_from_source_to_target<int>(unit, u)' \"Dangerous conversion: use .as<Rep>(NewUnit) instead\" static_assert(implicit_rep_permitted_from_source_to_target<Rep>(unit, u), ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ./au/quantity.hh:183:16: note: in instantiation of function template specialization 'au::Quantity<au::Giga<au::Hertz>, int>::as<au::Hertz, void>' requested here return as(NewUnit{}); ^ au/error_examples.cc:33:20: note: in instantiation of function template specialization 'au::Quantity<au::Giga<au::Hertz>, int>::as<au::Hertz>' requested here giga(hertz)(1).as(hertz); ^ Compiler error (gcc 10) ./au/quantity.hh: In instantiation of 'constexpr auto au::Quantity<UnitT, RepT>::as(NewUnit) const [with NewUnit = au::Feet; <template-parameter-2-2> = void; UnitT = au::Inches; RepT = int]': ./au/quantity.hh:183:18: required from 'constexpr auto au::Quantity<UnitT, RepT>::as(au::QuantityMaker<NewUnit>) const [with NewUnit = au::Feet; UnitT = au::Inches; RepT = int]' au/error_examples.cc:30:23: required from here ./au/quantity.hh:147:72: error: static assertion failed: Dangerous conversion: use .as<Rep>(NewUnit) instead 147 | static_assert(implicit_rep_permitted_from_source_to_target<Rep>(unit, u), | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~ ./au/quantity.hh: In instantiation of 'constexpr auto au::Quantity<UnitT, RepT>::as(NewUnit) const [with NewUnit = au::Hertz; <template-parameter-2-2> = void; UnitT = au::Giga<au::Hertz>; RepT = int]': ./au/quantity.hh:183:18: required from 'constexpr auto au::Quantity<UnitT, RepT>::as(au::QuantityMaker<NewUnit>) const [with NewUnit = au::Hertz; UnitT = au::Giga<au::Hertz>; RepT = int]' au/error_examples.cc:33:28: required from here ./au/quantity.hh:147:72: error: static assertion failed: Dangerous conversion: use .as<Rep>(NewUnit) instead No type named 'type' in 'std::common_type' \u00b6 Meaning: You probably tried to perform a \"common-unit operation\" (addition, subtraction, comparison) with two incompatible Quantities. Typically, this means they have different dimensions , which makes this an intrinsically meaningless operation. TODO Make a page which explains common-unit operations, and link to it. Solution: Figure out what dimension you expected them to have, and which value had the wrong dimension. Then, figure out how to fix your expression so it has the right dimension. Example Code Broken Fixed // (BROKEN): different dimensions. meters ( 1 ) + seconds ( 1 ); // (FIXED): fix coding mistake. meters ( 1 ) + seconds ( 1 ) * ( meters / second )( 10 ); Compiler error (clang 14) In file included from au/error_examples.cc:1: In file included from ./au/au.hh:5: In file included from external/llvm_14_toolchain_llvm/bin/../include/c++/v1/chrono:697: In file included from external/llvm_14_toolchain_llvm/bin/../include/c++/v1/__chrono/calendar.h:13: In file included from external/llvm_14_toolchain_llvm/bin/../include/c++/v1/__chrono/duration.h:14: In file included from external/llvm_14_toolchain_llvm/bin/../include/c++/v1/limits:105: external/llvm_14_toolchain_llvm/bin/../include/c++/v1/type_traits:2388:25: error: no type named 'type' in 'std::common_type<au::Quantity<au::Meters, int>, au::Quantity<au::Seconds, int>>' template <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type; ^~~~~ ./au/quantity.hh:494:20: note: in instantiation of template type alias 'common_type_t' requested here using C = std::common_type_t<T, U>; ^ ./au/quantity.hh:532:20: note: in instantiation of function template specialization 'au::detail::using_common_type<au::Quantity<au::Meters, int>, au::Quantity<au::Seconds, int>, au::detail::Plus>' requested here return detail::using_common_type(q1, q2, detail::plus); ^ au/error_examples.cc:41:15: note: in instantiation of function template specialization 'au::operator+<au::Meters, au::Seconds, int, int>' requested here meters(1) + seconds(1); ^ Compiler error (clang 11) In file included from au/error_examples.cc:1: In file included from ./au/au.hh:5: In file included from external/llvm_11_toolchain_llvm/bin/../include/c++/v1/chrono:828: external/llvm_11_toolchain_llvm/bin/../include/c++/v1/type_traits:2462:25: error: no type named 'type' in 'std::__1::common_type<au::Quantity<au::Meters, int>, au::Quantity<au::Seconds, int>>' template <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type; ^~~~~ ./au/quantity.hh:494:20: note: in instantiation of template type alias 'common_type_t' requested here using C = std::common_type_t<T, U>; ^ ./au/quantity.hh:532:20: note: in instantiation of function template specialization 'au::detail::using_common_type<au::Quantity<au::Meters, int>, au::Quantity<au::Seconds, int>, au::detail::Plus>' requested here return detail::using_common_type(q1, q2, detail::plus); ^ au/error_examples.cc:41:15: note: in instantiation of function template specialization 'au::operator+<au::Meters, au::Seconds, int, int>' requested here meters(1) + seconds(1); ^ Compiler error (gcc 10) In file included from external/sysroot_x86_64//include/c++/10.3.0/ratio:39, from external/sysroot_x86_64//include/c++/10.3.0/chrono:39, from ./au/au.hh:5, from au/error_examples.cc:1: external/sysroot_x86_64//include/c++/10.3.0/type_traits: In substitution of 'template<class ... _Tp> using common_type_t = typename std::common_type::type [with _Tp = {au::Quantity<au::Meters, int>, au::Quantity<au::Seconds, int>}]': ./au/quantity.hh:494:11: required from 'constexpr auto au::detail::using_common_type(T, U, Func) [with T = au::Quantity<au::Meters, int>; U = au::Quantity<au::Seconds, int>; Func = au::detail::Plus]' ./au/quantity.hh:532:37: required from 'constexpr auto au::operator+(au::Quantity<U1, R1>, au::Quantity<U2, R2>) [with U1 = au::Meters; U2 = au::Seconds; R1 = int; R2 = int]' au/error_examples.cc:41:26: required from here external/sysroot_x86_64//include/c++/10.3.0/type_traits:2562:11: error: no type named 'type' in 'struct std::common_type<au::Quantity<au::Meters, int>, au::Quantity<au::Seconds, int> >' 2562 | using common_type_t = typename common_type<_Tp...>::type; | ^~~~~~~~~~~~~ In file included from ./au/math.hh:8, from ./au/au.hh:7, from au/error_examples.cc:1: ./au/quantity.hh: In instantiation of 'constexpr auto au::detail::using_common_type(T, U, Func) [with T = au::Quantity<au::Meters, int>; U = au::Quantity<au::Seconds, int>; Func = au::detail::Plus]': ./au/quantity.hh:532:37: required from 'constexpr auto au::operator+(au::Quantity<U1, R1>, au::Quantity<U2, R2>) [with U1 = au::Meters; U2 = au::Seconds; R1 = int; R2 = int]' au/error_examples.cc:41:26: required from here Integer division forbidden \u00b6 Meaning: Although Au generally tries to act just like the underlying raw numeric types, we also try to prevent wrong code that looks correct from compiling. It turns out to be just too easy to use integral Reps without noticing, and thus to get integer division without noticing. This can lead to very large errors. Solution: If you really wanted integer division, call integer_quotient() . Otherwise, use floating point types. Example Code How long does it take to travel 60 m at a speed of 65 MPH? Broken Fixed (1. Floating point) Fixed (2. integer_quotient() ) // (BROKEN): gives (60 / 65) == 0 before conversion! QuantityD < Seconds > t = meters ( 60 ) / ( miles / hour )( 65 ); // (FIXED): 1. Using floating point, we get ~= seconds(2.06486) QuantityD < Seconds > t = meters ( 60.0 ) / ( miles / hour )( 65.0 ); // (FIXED): 2. Integer result == (meter * hours / mile)(0) auto t = integer_quotient ( meters ( 60 ), ( miles / hour )( 65 )); Compiler error (clang 14) In file included from au/error_examples.cc:1: In file included from ./au/au.hh:7: In file included from ./au/math.hh:8: ./au/quantity.hh:304:9: error: static_assert failed due to requirement '!uses_integer_division' \"Integer division forbidden: use integer_quotient() if you really want it\" static_assert(!uses_integer_division, ^ ~~~~~~~~~~~~~~~~~~~~~~ au/error_examples.cc:49:39: note: in instantiation of function template specialization 'au::Quantity<au::Meters, int>::operator/<au::UnitProduct<au::Miles, au::Pow<au::Hours, -1>>, int>' requested here QuantityD<Seconds> t = meters(60) / (miles / hour)(65); ^ Compiler error (clang 11) In file included from au/error_examples.cc:1: In file included from ./au/au.hh:7: In file included from ./au/math.hh:8: ./au/quantity.hh:304:9: error: static_assert failed due to requirement '!uses_integer_division' \"Integer division forbidden: use integer_quotient() if you really want it\" static_assert(!uses_integer_division, ^ ~~~~~~~~~~~~~~~~~~~~~~ au/error_examples.cc:49:39: note: in instantiation of function template specialization 'au::Quantity<au::Meters, int>::operator/<au::UnitProduct<au::Miles, au::Pow<au::Hours, -1>>, int>' requested here QuantityD<Seconds> t = meters(60) / (miles / hour)(65); ^ Compiler error (gcc 10) ./au/quantity.hh:496:94: error: no type named 'type' in 'struct std::common_type<au::Quantity<au::Meters, int>, au::Quantity<au::Seconds, int> >' 496 | std::is_same<typename C::Rep, std::common_type_t<typename T::Rep, typename U::Rep>>::value, | ^~~~~ ./au/quantity.hh: In instantiation of 'constexpr auto au::Quantity<UnitT, RepT>::operator/(au::Quantity<OtherUnit, OtherRep>) const [with OtherUnit = au::UnitProduct<au::Miles, au::Pow<au::Hours, -1> >; OtherRep = int; UnitT = au::Meters; RepT = int]': au/error_examples.cc:49:58: required from here ./au/quantity.hh:304:23: error: static assertion failed: Integer division forbidden: use integer_quotient() if you really want it 304 | static_assert(!uses_integer_division, | ^~~~~~~~~~~~~~~~~~~~~~ Dangerous inversion \u00b6 Meaning: This is analogous to our overflow safety surface. When computing the inverse of an integral quantity in a given target unit, there is some smallest value that will get truncated down to zero (a tremendous error!). If that value is \"small enough to be scary\" (currently 1,000), we forbid the conversion. Solution: Consider using floating point; you'll always get a precise answer. Alternatively, use a smaller target unit. Example Code Broken Fixed (1. Floating point) Fixed (2. Smaller target unit) // (BROKEN): excessive truncation risk. inverse_as ( seconds , hertz ( 5 )); // (FIXED): 1. Floating point result ~= seconds(0.2) inverse_as ( seconds , hertz ( 5.0 )); // (FIXED): 2. Integer result == milli(seconds)(200) inverse_as ( milli ( seconds ), hertz ( 5 )); Note If you're really sure it's OK, you can use the explicit-Rep version of inverse_as , which is forcing like a static_cast . This is rarely the right choice, though. Consider: inverse_as < int > ( seconds , hertz ( 5 )); This yields seconds(0) , due to the gross truncation error which the check was designed to prevent in the first place. Compiler error (clang 14) In file included from au/error_examples.cc:1: In file included from ./au/au.hh:7: ./au/math.hh:205:5: error: static_assert failed due to requirement 'make_quantity<au::UnitProduct<>>(int{1}).in(associated_unit(target_units) * au::Hertz{}) >= 1000 || std::is_floating_point<int>::value' \"Dangerous inversion risking truncation to 0; must supply explicit Rep if truly desired\" static_assert( ^ ./au/math.hh:221:56: note: in instantiation of function template specialization 'au::inverse_in<au::QuantityMaker<au::Seconds>, au::Hertz, int>' requested here return make_quantity<AssociatedUnitT<TargetUnits>>(inverse_in(target_units, q)); ^ au/error_examples.cc:57:5: note: in instantiation of function template specialization 'au::inverse_as<au::QuantityMaker<au::Seconds>, au::Hertz, int>' requested here inverse_as(seconds, hertz(5)); ^ Compiler error (clang 11) In file included from au/error_examples.cc:1: In file included from ./au/au.hh:7: ./au/math.hh:205:5: error: static_assert failed due to requirement 'make_quantity<au::UnitProduct<>>(int{1}).in(associated_unit(target_units) * au::Hertz{}) >= 1000 || std::is_floating_point<int>::value' \"Dangerous inversion risking truncation to 0; must supply explicit Rep if truly desired\" static_assert( ^ ./au/math.hh:221:56: note: in instantiation of function template specialization 'au::inverse_in<au::QuantityMaker<au::Seconds>, au::Hertz, int>' requested here return make_quantity<AssociatedUnitT<TargetUnits>>(inverse_in(target_units, q)); ^ au/error_examples.cc:57:5: note: in instantiation of function template specialization 'au::inverse_as<au::QuantityMaker<au::Seconds>, au::Hertz, int>' requested here inverse_as(seconds, hertz(5)); ^ Compiler error (gcc 10) In file included from ./au/au.hh:7, from au/error_examples.cc:1: ./au/math.hh: In instantiation of 'constexpr auto au::inverse_in(TargetUnits, au::Quantity<Unit, Rep>) [with TargetUnits = au::QuantityMaker<au::Seconds>; U = au::Hertz; R = int]': ./au/math.hh:221:66: required from 'constexpr auto au::inverse_as(TargetUnits, au::Quantity<Unit, Rep>) [with TargetUnits = au::QuantityMaker<au::Seconds>; U = au::Hertz; R = int]' au/error_examples.cc:57:33: required from here ./au/math.hh:206:93: error: static assertion failed: Dangerous inversion risking truncation to 0; must supply explicit Rep if truly desired 206 | make_quantity<UnitProductT<>>(R{1}).in(associated_unit(target_units) * U{}) >= 1000 || | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~ 207 | std::is_floating_point<R>::value, | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Deduced conflicting types \u00b6 Meaning: In some contexts, it's not enough to have Quantity types that can easily convert to each other. (Common examples include the ternary operator ?: , and initializer lists.) You need types that are identical, or very nearly so. Even fully quantity-equivalent types, such as \\text{Hz} \\text{Hz} and \\text{s}^{-1} \\text{s}^{-1} , often won't work in these contexts! Solution: You can always cast non-conforming instances to your favored unit, using .as() . For the initializer list case, you can also make an explicit container, which will handle the casting automatically when possible. Example Code Broken Fixed (1. Cast to explicit unit) Fixed (2. Use explicit container) // (BROKEN): Initializer list confused by Hz and s^(-1). for ( const auto & frequency : { hertz ( 1.0 ), ( 1 / seconds ( 2.0 )), }) { // ... } // (FIXED): 1. Cast individual elements to desired unit. for ( const auto & frequency : { hertz ( 1.0 ), ( 1 / seconds ( 2.0 )). as ( hertz ), }) { // ... } // (FIXED): 2. Use container with explicit type. for ( const auto & frequency : std :: vector < QuantityD < Hertz >> { hertz ( 1.0 ), ( 1 / seconds ( 2.0 )), }) { // ... } Compiler error (clang 14) au/error_examples.cc:65:34: error: deduced conflicting types ('Quantity<au::QuantityMaker<au::Hertz>::Unit, [...]>' vs 'Quantity<au::QuantityMaker<au::Pow<au::Seconds, -1>>::Unit, [...]>') for initializer list element type for (const auto &frequency : { ^ Compiler error (clang 11) au/error_examples.cc:65:34: error: deduced conflicting types ('Quantity<au::Hertz, [...]>' vs 'Quantity<au::Pow<au::Seconds, -1>, [...]>') for initializer list element type for (const auto &frequency : { ^ Compiler error (gcc 10) au/error_examples.cc: In function 'void au::example_deduced_conflicting_types()': au/error_examples.cc:68:10: error: unable to deduce 'std::initializer_list<auto>&&' from '{au::hertz.au::QuantityMaker<au::Hertz>::operator()<double>(1.0e+0), au::operator/<int>(1, au::seconds.au::QuantityMaker<au::Seconds>::operator()<double>(2.0e+0))}' 68 | }) { | ^ au/error_examples.cc:68:10: note: deduced conflicting types for parameter 'auto' ('au::Quantity<au::Hertz, double>' and 'au::Quantity<au::Pow<au::Seconds, -1>, double>') Broken strict total ordering \u00b6 Meaning: This means you performed an operation that needs to put unit types into a parameter pack --- say, a common unit, or a unit product --- but the library couldn't figure out how to order the units inside that pack. If that sounds obscure, it is: ordering units inside packs is a deep library implementation detail, and we try to avoid letting end users encounter this. To reach this error, you need two distinct units that have the same Dimension, Magnitude, and Origin. That's a necessary but not sufficient condition: for example, even UnitInverseT<Seconds> and Hertz won't trigger this! More background info on why this error exists In case you want to understand more, here is the gist. Au is heavily based on parameter packs. Some of these packs, such as UnitProduct<...> and CommonUnit<...> , take units as their arguments. TODO Make a doc page for parameter packs, and link to it here. Every parameter pack needs an unambiguous canonical ordering for any possible set of input arguments. Therefore, we need to create a strict total ordering for the (infinitely many!) unit types that could appear in these packs. This ordering needs to be known at compile time . The ordering itself doesn't matter so much, but if we don't strictly adhere to some ordering, it's undefined behaviour. Our strategy is to construct a \"gauntlet\" of properties which we can measure for any unit (e.g., Dimension, Magnitude, ...), and define some arbitrary ordering for each property. We then compare the units on each property in turn. The first one where they differ \"wins\". If we get through all the properties, and they're still tied, then we have two distinct unit types which compare as equal. This would be undefined behaviour! Rather than silently ignoring this, we manifest this as a compiler error. That is what \"broken strict total ordering\" means. Solution: If you have two distinct units, and the library can't figure out how to order them, you can force a particular ordering. Choose one of the units and give it a high \"unit avoidance\" score (see example below). This will break the tie. Again, this is pretty unusual. For most normal ways of forming units, the library should automatically be able to define an ordering for them. If you do hit this error, it may be worth pausing to double-check that you're using the library correctly. Tip If you hit this error, you might be annoyed by its obscurity. Instead, try feeling relieved! After all, the alternative is not \"correctly working program\", but \"silent undefined behaviour\". A compiler error with a searchable error message is infinitely preferable to the latter. Example Code Note that this example is somewhat convoluted, but again, that's to be expected because this error is pretty hard to hit in practice. Broken Fixed struct Quarterfeet : decltype ( Feet {} / mag < 4 > ()) {}; constexpr auto quarterfeet = QuantityMaker < Quarterfeet > {}; struct Trinches : decltype ( Inches {} * mag < 3 > ()) {}; constexpr auto trinches = QuantityMaker < Trinches > {}; // (BROKEN): Can't tell how to order Quarterfeet and Trinches when forming common type if ( quarterfeet ( 10 ) == trinches ( 10 )) { // ... } struct Quarterfeet : decltype ( Feet {} / mag < 4 > ()) {}; constexpr auto quarterfeet = QuantityMaker < Quarterfeet > {}; struct Trinches : decltype ( Inches {} * mag < 3 > ()) {}; constexpr auto trinches = QuantityMaker < Trinches > {}; namespace au { namespace detail { template <> struct UnitAvoidance <:: Trinches > : std :: integral_constant < int , 100 > {}; }} // (FIXED): Trinches has high \"unit avoidance\", so it goes after Quarterfeet if ( quarterfeet ( 10 ) == trinches ( 10 )) { // ... } Compiler error (clang 14) In file included from au/error_examples.cc:1: In file included from ./au/au.hh:7: In file included from ./au/math.hh:8: In file included from ./au/quantity.hh:7: In file included from ./au/conversion_policy.hh:7: In file included from ./au/magnitude.hh:7: ./au/packs.hh:276:5: error: static_assert failed due to requirement 'std::is_same<au::Quarterfeet, au::Trinches>::value' \"Broken strict total ordering: distinct input types compare equal\" static_assert(std::is_same<A, B>::value, ^ ~~~~~~~~~~~~~~~~~~~~~~~~~ ./au/packs.hh:292:5: note: in instantiation of template class 'au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches>' requested here std::conditional_t< ^ ./au/packs.hh:292:5: note: in instantiation of template class 'au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches, au::detail::OrderAsUnitProduct>' requested here ./au/packs.hh:292:5: note: in instantiation of template class 'au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches, au::detail::OrderByOrigin, au::detail::OrderAsUnitProduct>' requested here ./au/packs.hh:292:5: note: in instantiation of template class 'au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches, au::detail::OrderByMag, au::detail::OrderByOrigin, au::detail::OrderAsUnitProduct>' requested here ./au/packs.hh:292:5: note: in instantiation of template class 'au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches, au::detail::OrderByDim, au::detail::OrderByMag, au::detail::OrderByOrigin, au::detail::OrderAsUnitProduct>' requested here ./au/unit_of_measure.hh:868:40: note: (skipping 8 contexts in backtrace; use -ftemplate-backtrace-limit=0 to see all) struct InOrderFor<UnitProduct, A, B> : LexicographicTotalOrdering<A, ^ ./au/quantity.hh:631:7: note: in instantiation of template class 'au::CommonQuantity<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>>' requested here : au::CommonQuantity<au::Quantity<U1, R1>, au::Quantity<U2, R2>> {}; ^ external/llvm_14_toolchain_llvm/bin/../include/c++/v1/type_traits:2388:25: note: in instantiation of template class 'std::common_type<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>>' requested here template <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type; ^ ./au/quantity.hh:494:20: note: in instantiation of template type alias 'common_type_t' requested here using C = std::common_type_t<T, U>; ^ ./au/quantity.hh:506:20: note: in instantiation of function template specialization 'au::detail::using_common_type<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>, au::detail::Equal>' requested here return detail::using_common_type(q1, q2, detail::equal); ^ au/error_examples.cc:84:25: note: in instantiation of function template specialization 'au::operator==<au::Quarterfeet, au::Trinches, int, int>' requested here if (quarterfeet(10) == trinches(10)) { ^ Compiler error (clang 11) In file included from au/error_examples.cc:1: In file included from ./au/au.hh:7: In file included from ./au/math.hh:8: In file included from ./au/quantity.hh:7: In file included from ./au/conversion_policy.hh:7: In file included from ./au/magnitude.hh:7: ./au/packs.hh:276:5: error: static_assert failed due to requirement 'std::is_same<au::Quarterfeet, au::Trinches>::value' \"Broken strict total ordering: distinct input types compare equal\" static_assert(std::is_same<A, B>::value, ^ ~~~~~~~~~~~~~~~~~~~~~~~~~ ./au/packs.hh:292:5: note: in instantiation of template class 'au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches>' requested here std::conditional_t< ^ ./au/packs.hh:292:5: note: in instantiation of template class 'au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches, OrderAsUnitProduct>' requested here ./au/packs.hh:292:5: note: in instantiation of template class 'au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches, OrderByOrigin, OrderAsUnitProduct>' requested here ./au/packs.hh:292:5: note: in instantiation of template class 'au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches, OrderByMag, OrderByOrigin, OrderAsUnitProduct>' requested here ./au/packs.hh:292:5: note: in instantiation of template class 'au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches, OrderByDim, OrderByMag, OrderByOrigin, OrderAsUnitProduct>' requested here ./au/unit_of_measure.hh:868:40: note: (skipping 8 contexts in backtrace; use -ftemplate-backtrace-limit=0 to see all) struct InOrderFor<UnitProduct, A, B> : LexicographicTotalOrdering<A, ^ ./au/quantity.hh:631:7: note: in instantiation of template class 'au::CommonQuantity<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>, void>' requested here : au::CommonQuantity<au::Quantity<U1, R1>, au::Quantity<U2, R2>> {}; ^ external/llvm_11_toolchain_llvm/bin/../include/c++/v1/type_traits:2462:25: note: in instantiation of template class 'std::__1::common_type<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>>' requested here template <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type; ^ ./au/quantity.hh:494:20: note: in instantiation of template type alias 'common_type_t' requested here using C = std::common_type_t<T, U>; ^ ./au/quantity.hh:506:20: note: in instantiation of function template specialization 'au::detail::using_common_type<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>, au::detail::Equal>' requested here return detail::using_common_type(q1, q2, detail::equal); ^ au/error_examples.cc:84:25: note: in instantiation of function template specialization 'au::operator==<au::Quarterfeet, au::Trinches, int, int>' requested here if (quarterfeet(10) == trinches(10)) { ^ Compiler error (gcc 10) In file included from ./au/magnitude.hh:7, from ./au/conversion_policy.hh:7, from ./au/quantity.hh:7, from ./au/math.hh:8, from ./au/au.hh:7, from au/error_examples.cc:1: ./au/packs.hh: In instantiation of 'struct au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches>': ./au/packs.hh:287:8: recursively required from 'struct au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches, au::detail::OrderByDim, au::detail::OrderByMag, au::detail::OrderByOrigin, au::detail::OrderAsUnitProduct>' ./au/packs.hh:287:8: required from 'struct au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches, au::detail::OrderByUnitAvoidance, au::detail::OrderByDim, au::detail::OrderByMag, au::detail::OrderByOrigin, au::detail::OrderAsUnitProduct>' ./au/unit_of_measure.hh:868:8: required from 'struct au::InOrderFor<au::UnitProduct, au::Quarterfeet, au::Trinches>' ./au/unit_of_measure.hh:502:8: required from 'struct au::InOrderFor<au::CommonUnit, au::Quarterfeet, au::Trinches>' ./au/packs.hh:372:8: required from 'struct au::FlatDedupedTypeList<au::CommonUnit, au::CommonUnit<au::Quarterfeet>, au::CommonUnit<au::Trinches> >' ./au/unit_of_measure.hh:540:8: required from 'struct au::ComputeCommonUnit<au::Quarterfeet, au::Trinches>' ./au/quantity.hh:617:8: required from 'struct au::CommonQuantity<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>, void>' ./au/quantity.hh:630:8: required from 'struct std::common_type<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int> >' external/sysroot_x86_64//include/c++/10.3.0/type_traits:2562:11: required by substitution of 'template<class ... _Tp> using common_type_t = typename std::common_type::type [with _Tp = {au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>}]' ./au/quantity.hh:494:11: required from 'constexpr auto au::detail::using_common_type(T, U, Func) [with T = au::Quantity<au::Quarterfeet, int>; U = au::Quantity<au::Trinches, int>; Func = au::detail::Equal]' ./au/quantity.hh:506:37: required from 'constexpr bool au::operator==(au::Quantity<U1, R1>, au::Quantity<U2, R2>) [with U1 = au::Quarterfeet; U2 = au::Trinches; R1 = int; R2 = int]' au/error_examples.cc:84:39: required from here ./au/packs.hh:276:39: error: static assertion failed: Broken strict total ordering: distinct input types compare equal 276 | static_assert(std::is_same<A, B>::value, | ^~~~~ ./au/packs.hh: In instantiation of 'struct au::LexicographicTotalOrdering<au::Trinches, au::Quarterfeet>': ./au/packs.hh:287:8: required from 'struct au::LexicographicTotalOrdering<au::Trinches, au::Quarterfeet, au::detail::OrderByUnitAvoidance, au::detail::OrderByDim, au::detail::OrderByMag, au::detail::OrderByOrigin, au::detail::OrderAsUnitProduct>' ./au/unit_of_measure.hh:868:8: [ skipping 8 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ] ./au/unit_of_measure.hh:452:8: required from 'struct au::HasSameDimension<au::CommonUnit<au::Trinches, au::Quarterfeet>, au::Trinches>' ./au/stdx/type_traits.hh:26:61: required from 'struct au::stdx::conjunction<au::HasSameDimension<au::CommonUnit<au::Trinches, au::Quarterfeet>, au::Trinches>, au::detail::HasSameMagnitude<au::CommonUnit<au::Trinches, au::Quarterfeet>, au::Trinches> >' ./au/unit_of_measure.hh:467:8: required from 'struct au::AreUnitsQuantityEquivalent<au::CommonUnit<au::Trinches, au::Quarterfeet>, au::Trinches>' ./au/unit_of_measure.hh:529:8: required from 'struct au::detail::FirstMatchingUnit<au::AreUnitsQuantityEquivalent, au::CommonUnit<au::Trinches, au::Quarterfeet>, au::CommonUnit<au::Trinches, au::Quarterfeet> >' ./au/unit_of_measure.hh:540:8: required from 'struct au::ComputeCommonUnit<au::Quarterfeet, au::Trinches>' ./au/quantity.hh:617:8: required from 'struct au::CommonQuantity<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>, void>' ./au/quantity.hh:630:8: required from 'struct std::common_type<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int> >' external/sysroot_x86_64//include/c++/10.3.0/type_traits:2562:11: required by substitution of 'template<class ... _Tp> using common_type_t = typename std::common_type::type [with _Tp = {au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>}]' ./au/quantity.hh:494:11: required from 'constexpr auto au::detail::using_common_type(T, U, Func) [with T = au::Quantity<au::Quarterfeet, int>; U = au::Quantity<au::Trinches, int>; Func = au::detail::Equal]' ./au/quantity.hh:506:37: required from 'constexpr bool au::operator==(au::Quantity<U1, R1>, au::Quantity<U2, R2>) [with U1 = au::Quarterfeet; U2 = au::Trinches; R1 = int; R2 = int]' au/error_examples.cc:84:39: required from here ./au/packs.hh:276:39: error: static assertion failed: Broken strict total ordering: distinct input types compare equal In file included from ./au/conversion_policy.hh:10, from ./au/quantity.hh:7, from ./au/math.hh:8, from ./au/au.hh:7, from au/error_examples.cc:1: ./au/unit_of_measure.hh: In instantiation of 'struct au::CommonUnit<au::Trinches, au::Quarterfeet>': ./au/packs.hh:192:7: required by substitution of 'template<class U> using DimMemberT = typename U::Dim [with U = au::CommonUnit<au::Trinches, au::Quarterfeet>]' ./au/packs.hh:194:8: required from 'struct au::detail::DimImpl<au::CommonUnit<au::Trinches, au::Quarterfeet> >' ./au/unit_of_measure.hh:452:8: required from 'struct au::HasSameDimension<au::CommonUnit<au::Trinches, au::Quarterfeet>, au::Trinches>' ./au/stdx/type_traits.hh:26:61: required from 'struct au::stdx::conjunction<au::HasSameDimension<au::CommonUnit<au::Trinches, au::Quarterfeet>, au::Trinches>, au::detail::HasSameMagnitude<au::CommonUnit<au::Trinches, au::Quarterfeet>, au::Trinches> >' ./au/unit_of_measure.hh:467:8: [ skipping 2 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ] ./au/unit_of_measure.hh:540:8: required from 'struct au::ComputeCommonUnit<au::Quarterfeet, au::Trinches>' ./au/quantity.hh:617:8: required from 'struct au::CommonQuantity<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>, void>' ./au/quantity.hh:630:8: required from 'struct std::common_type<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int> >' external/sysroot_x86_64//include/c++/10.3.0/type_traits:2562:11: required by substitution of 'template<class ... _Tp> using common_type_t = typename std::common_type::type [with _Tp = {au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>}]' ./au/quantity.hh:494:11: required from 'constexpr auto au::detail::using_common_type(T, U, Func) [with T = au::Quantity<au::Quarterfeet, int>; U = au::Quantity<au::Trinches, int>; Func = au::detail::Equal]' ./au/quantity.hh:506:37: required from 'constexpr bool au::operator==(au::Quantity<U1, R1>, au::Quantity<U2, R2>) [with U1 = au::Quarterfeet; U2 = au::Trinches; R1 = int; R2 = int]' au/error_examples.cc:84:39: required from here ./au/unit_of_measure.hh:492:70: error: static assertion failed: Elements must be listed in ascending order 492 | static_assert(AreElementsInOrder<CommonUnit, CommonUnit<Us...>>::value, | ^~~~~","title":"Troubleshooting Guide"},{"location":"troubleshooting/#troubleshooting-guide","text":"This page is a guide to the most commonly encountered types of error, what they mean, and how to fix them. The intended use case is to help you interpret an actual error in your code , at the point where you encounter it. To use this page, copy some relevant snippets from your compiler error, and then search the text of this page using your browser's Find function. Tip To improve your chances of finding what you're looking for, we include full compiler errors from both gcc and clang, inline with the text. Naturally, this makes this page very long, so it's not meant to be read straight through. Stick with your browser's Find function. Each section below lists one category of compiler error you might encounter when using the library. It explains what it means and how to solve it, and gives specific snippets of erroneous code, along with the compiler errors that each would yield.","title":"Troubleshooting Guide"},{"location":"troubleshooting/#private-constructor","text":"Meaning: This means you passed a raw numeric value to an interface that expected a Quantity. It's the \"classic\" error the units library aims to prevent. Solution: Call the appropriate Quantity maker: instead of passing x , pass meters(x) , (kilo(meters) / hour)(x) , etc. A note on quantity makers vs. constructors Every other major units library lets you construct its Quantity types from raw numeric values; it just makes that constructor explicit. Au goes further, and makes this constructor private. The reason is to preserve unit safety at all callsites. We can't know whether you made an alias that doesn't name the unit. For example, if you want everybody to measure lengths in Meters in your codebase, you might provide a common alias like this: using Length = QuantityD < Meters > ; If you did, then end users could write the following: constexpr Length MAX_LENGTH { 5.5 }; // Unsafe! Units unclear. :( A core principle of the Au library is that the only way to enter or exit the library boundaries is to name the unit of measure, explicitly, at the callsite, like this: constexpr Length MAX_LENGTH = meters ( 5.5 ); // Usable! Units unambiguous. :) This enables users who want to use this kind of \"dimension-named alias\" in their codebase to do so safely. Example Code Broken Fixed void set_timeout ( QuantityD < Seconds > dt ); // A (BROKEN): passing raw number where duration expected. set_timeout ( 0.5 ); // B (BROKEN): calling Quantity constructor directly. constexpr QuantityD < Meters > length { 5.5 }; void set_timeout ( QuantityD < Seconds > dt ); // A (FIXED): name the unit. set_timeout ( seconds ( 0.5 )); // B (FIXED): calling Quantity constructor directly. constexpr QuantityD < Meters > length = meters ( 5.5 ); Compiler error (clang 14) au/error_examples.cc:19:17: error: calling a private constructor of class 'au::Quantity<au::Seconds, double>' set_timeout(0.5); ^ ./au/quantity.hh:369:15: note: declared private here constexpr Quantity(Rep value) : value_{value} {} ^ au/error_examples.cc:22:33: error: calling a private constructor of class 'au::Quantity<au::Meters, double>' constexpr QuantityD<Meters> length{5.5}; ^ ./au/quantity.hh:369:15: note: declared private here constexpr Quantity(Rep value) : value_{value} {} ^ Compiler error (clang 11) au/error_examples.cc:19:17: error: calling a private constructor of class 'au::Quantity<au::Seconds, double>' set_timeout(0.5); ^ ./au/quantity.hh:369:15: note: declared private here constexpr Quantity(Rep value) : value_{value} {} ^ au/error_examples.cc:22:33: error: calling a private constructor of class 'au::Quantity<au::Meters, double>' constexpr QuantityD<Meters> length{5.5}; ^ ./au/quantity.hh:369:15: note: declared private here constexpr Quantity(Rep value) : value_{value} {} ^ Compiler error (gcc 10) au/error_examples.cc: In function 'void au::example_private_constructor()': au/error_examples.cc:19:20: error: 'constexpr au::Quantity<UnitT, RepT>::Quantity(au::Quantity<UnitT, RepT>::Rep) [with UnitT = au::Seconds; RepT = double; au::Quantity<UnitT, RepT>::Rep = double]' is private within this context 19 | set_timeout(0.5); | ^ In file included from ./au/math.hh:8, from ./au/au.hh:7, from au/error_examples.cc:1: ./au/quantity.hh:369:15: note: declared private here 369 | constexpr Quantity(Rep value) : value_{value} {} | ^~~~~~~~ au/error_examples.cc:22:43: error: 'constexpr au::Quantity<UnitT, RepT>::Quantity(au::Quantity<UnitT, RepT>::Rep) [with UnitT = au::Meters; RepT = double; au::Quantity<UnitT, RepT>::Rep = double]' is private within this context 22 | constexpr QuantityD<Meters> length{5.5}; | ^ In file included from ./au/math.hh:8, from ./au/au.hh:7, from au/error_examples.cc:1: ./au/quantity.hh:369:15: note: declared private here 369 | constexpr Quantity(Rep value) : value_{value} {} | ^~~~~~~~","title":"Private constructor"},{"location":"troubleshooting/#dangerous-conversion","text":"Meaning: This is a physically meaningful conversion, but we think the risk of a grossly incorrect answer is too high, so we forbid it. There are two main sources for this risk, both having to do with integral storage types. Inexact conversion . Example: inches(24).as(feet) . Overflow . Example: giga(hertz)(1).as(hertz) . Both of these examples would in fact produce the correct answer with the specific values given ( 24 and 1 ). However, many (most!) other values would not. Thus, we disallow the entire conversion operation (at least in this format). Solution: There are different strategies to solve this, depending on your use case. Use floating point . As mentioned above, these risks only apply to integer values. If floating point is what you want anyway, just use it. giga(hertz)(1.0).as(hertz) produces hertz(1'000'000'000.0) . Use \"explicit Rep\" form . The \"Rep\" is the storage type for the Quantity. If you pass it as a template parameter, it is \"morally equivalent\" to a static_cast , and has the same \"forcing\" semantics. inches(24).as<int>(feet) produces feet(2) . Warning Stop and think before using the explicit Rep version. If you're reviewing code that uses it, ask about it. The library is trying to protect you from an error prone operation. The mechanism exists because sometimes you can know that it's OK, but remember to stop and check first! Example Code Broken Fixed (1. Floating Point) Fixed (2. Explicit Rep) // A (BROKEN): inexact conversion. inches ( 24 ). as ( feet ); // B (BROKEN): overflow risk. giga ( hertz )( 1 ). as ( hertz ); // A (FIXED): 1. use floating point. inches ( 24.0 ). as ( feet ); // B (FIXED): 1. use floating point. giga ( hertz )( 1.0 ). as ( hertz ); // A (FIXED): 2. provide explicit Rep. inches ( 24 ). as < int > ( feet ); // B (FIXED): 2. provide explicit Rep. giga ( hertz )( 1 ). as < int > ( hertz ); Compiler error (clang 14) ./au/quantity.hh:147:9: error: static_assert failed due to requirement 'implicit_rep_permitted_from_source_to_target<int>(unit, u)' \"Dangerous conversion: use .as<Rep>(NewUnit) instead\" static_assert(implicit_rep_permitted_from_source_to_target<Rep>(unit, u), ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ./au/quantity.hh:183:16: note: in instantiation of function template specialization 'au::Quantity<au::Inches, int>::as<au::Feet, void>' requested here return as(NewUnit{}); ^ au/error_examples.cc:30:16: note: in instantiation of function template specialization 'au::Quantity<au::Inches, int>::as<au::Feet>' requested here inches(24).as(feet); ^ In file included from au/error_examples.cc:1: In file included from ./au/au.hh:7: In file included from ./au/math.hh:8: ./au/quantity.hh:147:9: error: static_assert failed due to requirement 'implicit_rep_permitted_from_source_to_target<int>(unit, u)' \"Dangerous conversion: use .as<Rep>(NewUnit) instead\" static_assert(implicit_rep_permitted_from_source_to_target<Rep>(unit, u), ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ./au/quantity.hh:183:16: note: in instantiation of function template specialization 'au::Quantity<au::Giga<au::Hertz>, int>::as<au::Hertz, void>' requested here return as(NewUnit{}); ^ au/error_examples.cc:33:20: note: in instantiation of function template specialization 'au::Quantity<au::Giga<au::Hertz>, int>::as<au::Hertz>' requested here giga(hertz)(1).as(hertz); ^ Compiler error (clang 11) ./au/quantity.hh:147:9: error: static_assert failed due to requirement 'implicit_rep_permitted_from_source_to_target<int>(unit, u)' \"Dangerous conversion: use .as<Rep>(NewUnit) instead\" static_assert(implicit_rep_permitted_from_source_to_target<Rep>(unit, u), ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ./au/quantity.hh:183:16: note: in instantiation of function template specialization 'au::Quantity<au::Inches, int>::as<au::Feet, void>' requested here return as(NewUnit{}); ^ au/error_examples.cc:30:16: note: in instantiation of function template specialization 'au::Quantity<au::Inches, int>::as<au::Feet>' requested here inches(24).as(feet); ^ In file included from au/error_examples.cc:1: In file included from ./au/au.hh:7: In file included from ./au/math.hh:8: ./au/quantity.hh:147:9: error: static_assert failed due to requirement 'implicit_rep_permitted_from_source_to_target<int>(unit, u)' \"Dangerous conversion: use .as<Rep>(NewUnit) instead\" static_assert(implicit_rep_permitted_from_source_to_target<Rep>(unit, u), ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ./au/quantity.hh:183:16: note: in instantiation of function template specialization 'au::Quantity<au::Giga<au::Hertz>, int>::as<au::Hertz, void>' requested here return as(NewUnit{}); ^ au/error_examples.cc:33:20: note: in instantiation of function template specialization 'au::Quantity<au::Giga<au::Hertz>, int>::as<au::Hertz>' requested here giga(hertz)(1).as(hertz); ^ Compiler error (gcc 10) ./au/quantity.hh: In instantiation of 'constexpr auto au::Quantity<UnitT, RepT>::as(NewUnit) const [with NewUnit = au::Feet; <template-parameter-2-2> = void; UnitT = au::Inches; RepT = int]': ./au/quantity.hh:183:18: required from 'constexpr auto au::Quantity<UnitT, RepT>::as(au::QuantityMaker<NewUnit>) const [with NewUnit = au::Feet; UnitT = au::Inches; RepT = int]' au/error_examples.cc:30:23: required from here ./au/quantity.hh:147:72: error: static assertion failed: Dangerous conversion: use .as<Rep>(NewUnit) instead 147 | static_assert(implicit_rep_permitted_from_source_to_target<Rep>(unit, u), | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~ ./au/quantity.hh: In instantiation of 'constexpr auto au::Quantity<UnitT, RepT>::as(NewUnit) const [with NewUnit = au::Hertz; <template-parameter-2-2> = void; UnitT = au::Giga<au::Hertz>; RepT = int]': ./au/quantity.hh:183:18: required from 'constexpr auto au::Quantity<UnitT, RepT>::as(au::QuantityMaker<NewUnit>) const [with NewUnit = au::Hertz; UnitT = au::Giga<au::Hertz>; RepT = int]' au/error_examples.cc:33:28: required from here ./au/quantity.hh:147:72: error: static assertion failed: Dangerous conversion: use .as<Rep>(NewUnit) instead","title":"Dangerous conversion"},{"location":"troubleshooting/#no-type-named-type-in-stdcommon_type","text":"Meaning: You probably tried to perform a \"common-unit operation\" (addition, subtraction, comparison) with two incompatible Quantities. Typically, this means they have different dimensions , which makes this an intrinsically meaningless operation. TODO Make a page which explains common-unit operations, and link to it. Solution: Figure out what dimension you expected them to have, and which value had the wrong dimension. Then, figure out how to fix your expression so it has the right dimension. Example Code Broken Fixed // (BROKEN): different dimensions. meters ( 1 ) + seconds ( 1 ); // (FIXED): fix coding mistake. meters ( 1 ) + seconds ( 1 ) * ( meters / second )( 10 ); Compiler error (clang 14) In file included from au/error_examples.cc:1: In file included from ./au/au.hh:5: In file included from external/llvm_14_toolchain_llvm/bin/../include/c++/v1/chrono:697: In file included from external/llvm_14_toolchain_llvm/bin/../include/c++/v1/__chrono/calendar.h:13: In file included from external/llvm_14_toolchain_llvm/bin/../include/c++/v1/__chrono/duration.h:14: In file included from external/llvm_14_toolchain_llvm/bin/../include/c++/v1/limits:105: external/llvm_14_toolchain_llvm/bin/../include/c++/v1/type_traits:2388:25: error: no type named 'type' in 'std::common_type<au::Quantity<au::Meters, int>, au::Quantity<au::Seconds, int>>' template <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type; ^~~~~ ./au/quantity.hh:494:20: note: in instantiation of template type alias 'common_type_t' requested here using C = std::common_type_t<T, U>; ^ ./au/quantity.hh:532:20: note: in instantiation of function template specialization 'au::detail::using_common_type<au::Quantity<au::Meters, int>, au::Quantity<au::Seconds, int>, au::detail::Plus>' requested here return detail::using_common_type(q1, q2, detail::plus); ^ au/error_examples.cc:41:15: note: in instantiation of function template specialization 'au::operator+<au::Meters, au::Seconds, int, int>' requested here meters(1) + seconds(1); ^ Compiler error (clang 11) In file included from au/error_examples.cc:1: In file included from ./au/au.hh:5: In file included from external/llvm_11_toolchain_llvm/bin/../include/c++/v1/chrono:828: external/llvm_11_toolchain_llvm/bin/../include/c++/v1/type_traits:2462:25: error: no type named 'type' in 'std::__1::common_type<au::Quantity<au::Meters, int>, au::Quantity<au::Seconds, int>>' template <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type; ^~~~~ ./au/quantity.hh:494:20: note: in instantiation of template type alias 'common_type_t' requested here using C = std::common_type_t<T, U>; ^ ./au/quantity.hh:532:20: note: in instantiation of function template specialization 'au::detail::using_common_type<au::Quantity<au::Meters, int>, au::Quantity<au::Seconds, int>, au::detail::Plus>' requested here return detail::using_common_type(q1, q2, detail::plus); ^ au/error_examples.cc:41:15: note: in instantiation of function template specialization 'au::operator+<au::Meters, au::Seconds, int, int>' requested here meters(1) + seconds(1); ^ Compiler error (gcc 10) In file included from external/sysroot_x86_64//include/c++/10.3.0/ratio:39, from external/sysroot_x86_64//include/c++/10.3.0/chrono:39, from ./au/au.hh:5, from au/error_examples.cc:1: external/sysroot_x86_64//include/c++/10.3.0/type_traits: In substitution of 'template<class ... _Tp> using common_type_t = typename std::common_type::type [with _Tp = {au::Quantity<au::Meters, int>, au::Quantity<au::Seconds, int>}]': ./au/quantity.hh:494:11: required from 'constexpr auto au::detail::using_common_type(T, U, Func) [with T = au::Quantity<au::Meters, int>; U = au::Quantity<au::Seconds, int>; Func = au::detail::Plus]' ./au/quantity.hh:532:37: required from 'constexpr auto au::operator+(au::Quantity<U1, R1>, au::Quantity<U2, R2>) [with U1 = au::Meters; U2 = au::Seconds; R1 = int; R2 = int]' au/error_examples.cc:41:26: required from here external/sysroot_x86_64//include/c++/10.3.0/type_traits:2562:11: error: no type named 'type' in 'struct std::common_type<au::Quantity<au::Meters, int>, au::Quantity<au::Seconds, int> >' 2562 | using common_type_t = typename common_type<_Tp...>::type; | ^~~~~~~~~~~~~ In file included from ./au/math.hh:8, from ./au/au.hh:7, from au/error_examples.cc:1: ./au/quantity.hh: In instantiation of 'constexpr auto au::detail::using_common_type(T, U, Func) [with T = au::Quantity<au::Meters, int>; U = au::Quantity<au::Seconds, int>; Func = au::detail::Plus]': ./au/quantity.hh:532:37: required from 'constexpr auto au::operator+(au::Quantity<U1, R1>, au::Quantity<U2, R2>) [with U1 = au::Meters; U2 = au::Seconds; R1 = int; R2 = int]' au/error_examples.cc:41:26: required from here","title":"No type named 'type' in 'std::common_type'"},{"location":"troubleshooting/#integer-division-forbidden","text":"Meaning: Although Au generally tries to act just like the underlying raw numeric types, we also try to prevent wrong code that looks correct from compiling. It turns out to be just too easy to use integral Reps without noticing, and thus to get integer division without noticing. This can lead to very large errors. Solution: If you really wanted integer division, call integer_quotient() . Otherwise, use floating point types. Example Code How long does it take to travel 60 m at a speed of 65 MPH? Broken Fixed (1. Floating point) Fixed (2. integer_quotient() ) // (BROKEN): gives (60 / 65) == 0 before conversion! QuantityD < Seconds > t = meters ( 60 ) / ( miles / hour )( 65 ); // (FIXED): 1. Using floating point, we get ~= seconds(2.06486) QuantityD < Seconds > t = meters ( 60.0 ) / ( miles / hour )( 65.0 ); // (FIXED): 2. Integer result == (meter * hours / mile)(0) auto t = integer_quotient ( meters ( 60 ), ( miles / hour )( 65 )); Compiler error (clang 14) In file included from au/error_examples.cc:1: In file included from ./au/au.hh:7: In file included from ./au/math.hh:8: ./au/quantity.hh:304:9: error: static_assert failed due to requirement '!uses_integer_division' \"Integer division forbidden: use integer_quotient() if you really want it\" static_assert(!uses_integer_division, ^ ~~~~~~~~~~~~~~~~~~~~~~ au/error_examples.cc:49:39: note: in instantiation of function template specialization 'au::Quantity<au::Meters, int>::operator/<au::UnitProduct<au::Miles, au::Pow<au::Hours, -1>>, int>' requested here QuantityD<Seconds> t = meters(60) / (miles / hour)(65); ^ Compiler error (clang 11) In file included from au/error_examples.cc:1: In file included from ./au/au.hh:7: In file included from ./au/math.hh:8: ./au/quantity.hh:304:9: error: static_assert failed due to requirement '!uses_integer_division' \"Integer division forbidden: use integer_quotient() if you really want it\" static_assert(!uses_integer_division, ^ ~~~~~~~~~~~~~~~~~~~~~~ au/error_examples.cc:49:39: note: in instantiation of function template specialization 'au::Quantity<au::Meters, int>::operator/<au::UnitProduct<au::Miles, au::Pow<au::Hours, -1>>, int>' requested here QuantityD<Seconds> t = meters(60) / (miles / hour)(65); ^ Compiler error (gcc 10) ./au/quantity.hh:496:94: error: no type named 'type' in 'struct std::common_type<au::Quantity<au::Meters, int>, au::Quantity<au::Seconds, int> >' 496 | std::is_same<typename C::Rep, std::common_type_t<typename T::Rep, typename U::Rep>>::value, | ^~~~~ ./au/quantity.hh: In instantiation of 'constexpr auto au::Quantity<UnitT, RepT>::operator/(au::Quantity<OtherUnit, OtherRep>) const [with OtherUnit = au::UnitProduct<au::Miles, au::Pow<au::Hours, -1> >; OtherRep = int; UnitT = au::Meters; RepT = int]': au/error_examples.cc:49:58: required from here ./au/quantity.hh:304:23: error: static assertion failed: Integer division forbidden: use integer_quotient() if you really want it 304 | static_assert(!uses_integer_division, | ^~~~~~~~~~~~~~~~~~~~~~","title":"Integer division forbidden"},{"location":"troubleshooting/#dangerous-inversion","text":"Meaning: This is analogous to our overflow safety surface. When computing the inverse of an integral quantity in a given target unit, there is some smallest value that will get truncated down to zero (a tremendous error!). If that value is \"small enough to be scary\" (currently 1,000), we forbid the conversion. Solution: Consider using floating point; you'll always get a precise answer. Alternatively, use a smaller target unit. Example Code Broken Fixed (1. Floating point) Fixed (2. Smaller target unit) // (BROKEN): excessive truncation risk. inverse_as ( seconds , hertz ( 5 )); // (FIXED): 1. Floating point result ~= seconds(0.2) inverse_as ( seconds , hertz ( 5.0 )); // (FIXED): 2. Integer result == milli(seconds)(200) inverse_as ( milli ( seconds ), hertz ( 5 )); Note If you're really sure it's OK, you can use the explicit-Rep version of inverse_as , which is forcing like a static_cast . This is rarely the right choice, though. Consider: inverse_as < int > ( seconds , hertz ( 5 )); This yields seconds(0) , due to the gross truncation error which the check was designed to prevent in the first place. Compiler error (clang 14) In file included from au/error_examples.cc:1: In file included from ./au/au.hh:7: ./au/math.hh:205:5: error: static_assert failed due to requirement 'make_quantity<au::UnitProduct<>>(int{1}).in(associated_unit(target_units) * au::Hertz{}) >= 1000 || std::is_floating_point<int>::value' \"Dangerous inversion risking truncation to 0; must supply explicit Rep if truly desired\" static_assert( ^ ./au/math.hh:221:56: note: in instantiation of function template specialization 'au::inverse_in<au::QuantityMaker<au::Seconds>, au::Hertz, int>' requested here return make_quantity<AssociatedUnitT<TargetUnits>>(inverse_in(target_units, q)); ^ au/error_examples.cc:57:5: note: in instantiation of function template specialization 'au::inverse_as<au::QuantityMaker<au::Seconds>, au::Hertz, int>' requested here inverse_as(seconds, hertz(5)); ^ Compiler error (clang 11) In file included from au/error_examples.cc:1: In file included from ./au/au.hh:7: ./au/math.hh:205:5: error: static_assert failed due to requirement 'make_quantity<au::UnitProduct<>>(int{1}).in(associated_unit(target_units) * au::Hertz{}) >= 1000 || std::is_floating_point<int>::value' \"Dangerous inversion risking truncation to 0; must supply explicit Rep if truly desired\" static_assert( ^ ./au/math.hh:221:56: note: in instantiation of function template specialization 'au::inverse_in<au::QuantityMaker<au::Seconds>, au::Hertz, int>' requested here return make_quantity<AssociatedUnitT<TargetUnits>>(inverse_in(target_units, q)); ^ au/error_examples.cc:57:5: note: in instantiation of function template specialization 'au::inverse_as<au::QuantityMaker<au::Seconds>, au::Hertz, int>' requested here inverse_as(seconds, hertz(5)); ^ Compiler error (gcc 10) In file included from ./au/au.hh:7, from au/error_examples.cc:1: ./au/math.hh: In instantiation of 'constexpr auto au::inverse_in(TargetUnits, au::Quantity<Unit, Rep>) [with TargetUnits = au::QuantityMaker<au::Seconds>; U = au::Hertz; R = int]': ./au/math.hh:221:66: required from 'constexpr auto au::inverse_as(TargetUnits, au::Quantity<Unit, Rep>) [with TargetUnits = au::QuantityMaker<au::Seconds>; U = au::Hertz; R = int]' au/error_examples.cc:57:33: required from here ./au/math.hh:206:93: error: static assertion failed: Dangerous inversion risking truncation to 0; must supply explicit Rep if truly desired 206 | make_quantity<UnitProductT<>>(R{1}).in(associated_unit(target_units) * U{}) >= 1000 || | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~ 207 | std::is_floating_point<R>::value, | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","title":"Dangerous inversion"},{"location":"troubleshooting/#deduced-conflicting-types","text":"Meaning: In some contexts, it's not enough to have Quantity types that can easily convert to each other. (Common examples include the ternary operator ?: , and initializer lists.) You need types that are identical, or very nearly so. Even fully quantity-equivalent types, such as \\text{Hz} \\text{Hz} and \\text{s}^{-1} \\text{s}^{-1} , often won't work in these contexts! Solution: You can always cast non-conforming instances to your favored unit, using .as() . For the initializer list case, you can also make an explicit container, which will handle the casting automatically when possible. Example Code Broken Fixed (1. Cast to explicit unit) Fixed (2. Use explicit container) // (BROKEN): Initializer list confused by Hz and s^(-1). for ( const auto & frequency : { hertz ( 1.0 ), ( 1 / seconds ( 2.0 )), }) { // ... } // (FIXED): 1. Cast individual elements to desired unit. for ( const auto & frequency : { hertz ( 1.0 ), ( 1 / seconds ( 2.0 )). as ( hertz ), }) { // ... } // (FIXED): 2. Use container with explicit type. for ( const auto & frequency : std :: vector < QuantityD < Hertz >> { hertz ( 1.0 ), ( 1 / seconds ( 2.0 )), }) { // ... } Compiler error (clang 14) au/error_examples.cc:65:34: error: deduced conflicting types ('Quantity<au::QuantityMaker<au::Hertz>::Unit, [...]>' vs 'Quantity<au::QuantityMaker<au::Pow<au::Seconds, -1>>::Unit, [...]>') for initializer list element type for (const auto &frequency : { ^ Compiler error (clang 11) au/error_examples.cc:65:34: error: deduced conflicting types ('Quantity<au::Hertz, [...]>' vs 'Quantity<au::Pow<au::Seconds, -1>, [...]>') for initializer list element type for (const auto &frequency : { ^ Compiler error (gcc 10) au/error_examples.cc: In function 'void au::example_deduced_conflicting_types()': au/error_examples.cc:68:10: error: unable to deduce 'std::initializer_list<auto>&&' from '{au::hertz.au::QuantityMaker<au::Hertz>::operator()<double>(1.0e+0), au::operator/<int>(1, au::seconds.au::QuantityMaker<au::Seconds>::operator()<double>(2.0e+0))}' 68 | }) { | ^ au/error_examples.cc:68:10: note: deduced conflicting types for parameter 'auto' ('au::Quantity<au::Hertz, double>' and 'au::Quantity<au::Pow<au::Seconds, -1>, double>')","title":"Deduced conflicting types"},{"location":"troubleshooting/#broken-strict-total-ordering","text":"Meaning: This means you performed an operation that needs to put unit types into a parameter pack --- say, a common unit, or a unit product --- but the library couldn't figure out how to order the units inside that pack. If that sounds obscure, it is: ordering units inside packs is a deep library implementation detail, and we try to avoid letting end users encounter this. To reach this error, you need two distinct units that have the same Dimension, Magnitude, and Origin. That's a necessary but not sufficient condition: for example, even UnitInverseT<Seconds> and Hertz won't trigger this! More background info on why this error exists In case you want to understand more, here is the gist. Au is heavily based on parameter packs. Some of these packs, such as UnitProduct<...> and CommonUnit<...> , take units as their arguments. TODO Make a doc page for parameter packs, and link to it here. Every parameter pack needs an unambiguous canonical ordering for any possible set of input arguments. Therefore, we need to create a strict total ordering for the (infinitely many!) unit types that could appear in these packs. This ordering needs to be known at compile time . The ordering itself doesn't matter so much, but if we don't strictly adhere to some ordering, it's undefined behaviour. Our strategy is to construct a \"gauntlet\" of properties which we can measure for any unit (e.g., Dimension, Magnitude, ...), and define some arbitrary ordering for each property. We then compare the units on each property in turn. The first one where they differ \"wins\". If we get through all the properties, and they're still tied, then we have two distinct unit types which compare as equal. This would be undefined behaviour! Rather than silently ignoring this, we manifest this as a compiler error. That is what \"broken strict total ordering\" means. Solution: If you have two distinct units, and the library can't figure out how to order them, you can force a particular ordering. Choose one of the units and give it a high \"unit avoidance\" score (see example below). This will break the tie. Again, this is pretty unusual. For most normal ways of forming units, the library should automatically be able to define an ordering for them. If you do hit this error, it may be worth pausing to double-check that you're using the library correctly. Tip If you hit this error, you might be annoyed by its obscurity. Instead, try feeling relieved! After all, the alternative is not \"correctly working program\", but \"silent undefined behaviour\". A compiler error with a searchable error message is infinitely preferable to the latter. Example Code Note that this example is somewhat convoluted, but again, that's to be expected because this error is pretty hard to hit in practice. Broken Fixed struct Quarterfeet : decltype ( Feet {} / mag < 4 > ()) {}; constexpr auto quarterfeet = QuantityMaker < Quarterfeet > {}; struct Trinches : decltype ( Inches {} * mag < 3 > ()) {}; constexpr auto trinches = QuantityMaker < Trinches > {}; // (BROKEN): Can't tell how to order Quarterfeet and Trinches when forming common type if ( quarterfeet ( 10 ) == trinches ( 10 )) { // ... } struct Quarterfeet : decltype ( Feet {} / mag < 4 > ()) {}; constexpr auto quarterfeet = QuantityMaker < Quarterfeet > {}; struct Trinches : decltype ( Inches {} * mag < 3 > ()) {}; constexpr auto trinches = QuantityMaker < Trinches > {}; namespace au { namespace detail { template <> struct UnitAvoidance <:: Trinches > : std :: integral_constant < int , 100 > {}; }} // (FIXED): Trinches has high \"unit avoidance\", so it goes after Quarterfeet if ( quarterfeet ( 10 ) == trinches ( 10 )) { // ... } Compiler error (clang 14) In file included from au/error_examples.cc:1: In file included from ./au/au.hh:7: In file included from ./au/math.hh:8: In file included from ./au/quantity.hh:7: In file included from ./au/conversion_policy.hh:7: In file included from ./au/magnitude.hh:7: ./au/packs.hh:276:5: error: static_assert failed due to requirement 'std::is_same<au::Quarterfeet, au::Trinches>::value' \"Broken strict total ordering: distinct input types compare equal\" static_assert(std::is_same<A, B>::value, ^ ~~~~~~~~~~~~~~~~~~~~~~~~~ ./au/packs.hh:292:5: note: in instantiation of template class 'au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches>' requested here std::conditional_t< ^ ./au/packs.hh:292:5: note: in instantiation of template class 'au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches, au::detail::OrderAsUnitProduct>' requested here ./au/packs.hh:292:5: note: in instantiation of template class 'au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches, au::detail::OrderByOrigin, au::detail::OrderAsUnitProduct>' requested here ./au/packs.hh:292:5: note: in instantiation of template class 'au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches, au::detail::OrderByMag, au::detail::OrderByOrigin, au::detail::OrderAsUnitProduct>' requested here ./au/packs.hh:292:5: note: in instantiation of template class 'au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches, au::detail::OrderByDim, au::detail::OrderByMag, au::detail::OrderByOrigin, au::detail::OrderAsUnitProduct>' requested here ./au/unit_of_measure.hh:868:40: note: (skipping 8 contexts in backtrace; use -ftemplate-backtrace-limit=0 to see all) struct InOrderFor<UnitProduct, A, B> : LexicographicTotalOrdering<A, ^ ./au/quantity.hh:631:7: note: in instantiation of template class 'au::CommonQuantity<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>>' requested here : au::CommonQuantity<au::Quantity<U1, R1>, au::Quantity<U2, R2>> {}; ^ external/llvm_14_toolchain_llvm/bin/../include/c++/v1/type_traits:2388:25: note: in instantiation of template class 'std::common_type<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>>' requested here template <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type; ^ ./au/quantity.hh:494:20: note: in instantiation of template type alias 'common_type_t' requested here using C = std::common_type_t<T, U>; ^ ./au/quantity.hh:506:20: note: in instantiation of function template specialization 'au::detail::using_common_type<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>, au::detail::Equal>' requested here return detail::using_common_type(q1, q2, detail::equal); ^ au/error_examples.cc:84:25: note: in instantiation of function template specialization 'au::operator==<au::Quarterfeet, au::Trinches, int, int>' requested here if (quarterfeet(10) == trinches(10)) { ^ Compiler error (clang 11) In file included from au/error_examples.cc:1: In file included from ./au/au.hh:7: In file included from ./au/math.hh:8: In file included from ./au/quantity.hh:7: In file included from ./au/conversion_policy.hh:7: In file included from ./au/magnitude.hh:7: ./au/packs.hh:276:5: error: static_assert failed due to requirement 'std::is_same<au::Quarterfeet, au::Trinches>::value' \"Broken strict total ordering: distinct input types compare equal\" static_assert(std::is_same<A, B>::value, ^ ~~~~~~~~~~~~~~~~~~~~~~~~~ ./au/packs.hh:292:5: note: in instantiation of template class 'au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches>' requested here std::conditional_t< ^ ./au/packs.hh:292:5: note: in instantiation of template class 'au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches, OrderAsUnitProduct>' requested here ./au/packs.hh:292:5: note: in instantiation of template class 'au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches, OrderByOrigin, OrderAsUnitProduct>' requested here ./au/packs.hh:292:5: note: in instantiation of template class 'au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches, OrderByMag, OrderByOrigin, OrderAsUnitProduct>' requested here ./au/packs.hh:292:5: note: in instantiation of template class 'au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches, OrderByDim, OrderByMag, OrderByOrigin, OrderAsUnitProduct>' requested here ./au/unit_of_measure.hh:868:40: note: (skipping 8 contexts in backtrace; use -ftemplate-backtrace-limit=0 to see all) struct InOrderFor<UnitProduct, A, B> : LexicographicTotalOrdering<A, ^ ./au/quantity.hh:631:7: note: in instantiation of template class 'au::CommonQuantity<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>, void>' requested here : au::CommonQuantity<au::Quantity<U1, R1>, au::Quantity<U2, R2>> {}; ^ external/llvm_11_toolchain_llvm/bin/../include/c++/v1/type_traits:2462:25: note: in instantiation of template class 'std::__1::common_type<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>>' requested here template <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type; ^ ./au/quantity.hh:494:20: note: in instantiation of template type alias 'common_type_t' requested here using C = std::common_type_t<T, U>; ^ ./au/quantity.hh:506:20: note: in instantiation of function template specialization 'au::detail::using_common_type<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>, au::detail::Equal>' requested here return detail::using_common_type(q1, q2, detail::equal); ^ au/error_examples.cc:84:25: note: in instantiation of function template specialization 'au::operator==<au::Quarterfeet, au::Trinches, int, int>' requested here if (quarterfeet(10) == trinches(10)) { ^ Compiler error (gcc 10) In file included from ./au/magnitude.hh:7, from ./au/conversion_policy.hh:7, from ./au/quantity.hh:7, from ./au/math.hh:8, from ./au/au.hh:7, from au/error_examples.cc:1: ./au/packs.hh: In instantiation of 'struct au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches>': ./au/packs.hh:287:8: recursively required from 'struct au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches, au::detail::OrderByDim, au::detail::OrderByMag, au::detail::OrderByOrigin, au::detail::OrderAsUnitProduct>' ./au/packs.hh:287:8: required from 'struct au::LexicographicTotalOrdering<au::Quarterfeet, au::Trinches, au::detail::OrderByUnitAvoidance, au::detail::OrderByDim, au::detail::OrderByMag, au::detail::OrderByOrigin, au::detail::OrderAsUnitProduct>' ./au/unit_of_measure.hh:868:8: required from 'struct au::InOrderFor<au::UnitProduct, au::Quarterfeet, au::Trinches>' ./au/unit_of_measure.hh:502:8: required from 'struct au::InOrderFor<au::CommonUnit, au::Quarterfeet, au::Trinches>' ./au/packs.hh:372:8: required from 'struct au::FlatDedupedTypeList<au::CommonUnit, au::CommonUnit<au::Quarterfeet>, au::CommonUnit<au::Trinches> >' ./au/unit_of_measure.hh:540:8: required from 'struct au::ComputeCommonUnit<au::Quarterfeet, au::Trinches>' ./au/quantity.hh:617:8: required from 'struct au::CommonQuantity<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>, void>' ./au/quantity.hh:630:8: required from 'struct std::common_type<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int> >' external/sysroot_x86_64//include/c++/10.3.0/type_traits:2562:11: required by substitution of 'template<class ... _Tp> using common_type_t = typename std::common_type::type [with _Tp = {au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>}]' ./au/quantity.hh:494:11: required from 'constexpr auto au::detail::using_common_type(T, U, Func) [with T = au::Quantity<au::Quarterfeet, int>; U = au::Quantity<au::Trinches, int>; Func = au::detail::Equal]' ./au/quantity.hh:506:37: required from 'constexpr bool au::operator==(au::Quantity<U1, R1>, au::Quantity<U2, R2>) [with U1 = au::Quarterfeet; U2 = au::Trinches; R1 = int; R2 = int]' au/error_examples.cc:84:39: required from here ./au/packs.hh:276:39: error: static assertion failed: Broken strict total ordering: distinct input types compare equal 276 | static_assert(std::is_same<A, B>::value, | ^~~~~ ./au/packs.hh: In instantiation of 'struct au::LexicographicTotalOrdering<au::Trinches, au::Quarterfeet>': ./au/packs.hh:287:8: required from 'struct au::LexicographicTotalOrdering<au::Trinches, au::Quarterfeet, au::detail::OrderByUnitAvoidance, au::detail::OrderByDim, au::detail::OrderByMag, au::detail::OrderByOrigin, au::detail::OrderAsUnitProduct>' ./au/unit_of_measure.hh:868:8: [ skipping 8 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ] ./au/unit_of_measure.hh:452:8: required from 'struct au::HasSameDimension<au::CommonUnit<au::Trinches, au::Quarterfeet>, au::Trinches>' ./au/stdx/type_traits.hh:26:61: required from 'struct au::stdx::conjunction<au::HasSameDimension<au::CommonUnit<au::Trinches, au::Quarterfeet>, au::Trinches>, au::detail::HasSameMagnitude<au::CommonUnit<au::Trinches, au::Quarterfeet>, au::Trinches> >' ./au/unit_of_measure.hh:467:8: required from 'struct au::AreUnitsQuantityEquivalent<au::CommonUnit<au::Trinches, au::Quarterfeet>, au::Trinches>' ./au/unit_of_measure.hh:529:8: required from 'struct au::detail::FirstMatchingUnit<au::AreUnitsQuantityEquivalent, au::CommonUnit<au::Trinches, au::Quarterfeet>, au::CommonUnit<au::Trinches, au::Quarterfeet> >' ./au/unit_of_measure.hh:540:8: required from 'struct au::ComputeCommonUnit<au::Quarterfeet, au::Trinches>' ./au/quantity.hh:617:8: required from 'struct au::CommonQuantity<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>, void>' ./au/quantity.hh:630:8: required from 'struct std::common_type<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int> >' external/sysroot_x86_64//include/c++/10.3.0/type_traits:2562:11: required by substitution of 'template<class ... _Tp> using common_type_t = typename std::common_type::type [with _Tp = {au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>}]' ./au/quantity.hh:494:11: required from 'constexpr auto au::detail::using_common_type(T, U, Func) [with T = au::Quantity<au::Quarterfeet, int>; U = au::Quantity<au::Trinches, int>; Func = au::detail::Equal]' ./au/quantity.hh:506:37: required from 'constexpr bool au::operator==(au::Quantity<U1, R1>, au::Quantity<U2, R2>) [with U1 = au::Quarterfeet; U2 = au::Trinches; R1 = int; R2 = int]' au/error_examples.cc:84:39: required from here ./au/packs.hh:276:39: error: static assertion failed: Broken strict total ordering: distinct input types compare equal In file included from ./au/conversion_policy.hh:10, from ./au/quantity.hh:7, from ./au/math.hh:8, from ./au/au.hh:7, from au/error_examples.cc:1: ./au/unit_of_measure.hh: In instantiation of 'struct au::CommonUnit<au::Trinches, au::Quarterfeet>': ./au/packs.hh:192:7: required by substitution of 'template<class U> using DimMemberT = typename U::Dim [with U = au::CommonUnit<au::Trinches, au::Quarterfeet>]' ./au/packs.hh:194:8: required from 'struct au::detail::DimImpl<au::CommonUnit<au::Trinches, au::Quarterfeet> >' ./au/unit_of_measure.hh:452:8: required from 'struct au::HasSameDimension<au::CommonUnit<au::Trinches, au::Quarterfeet>, au::Trinches>' ./au/stdx/type_traits.hh:26:61: required from 'struct au::stdx::conjunction<au::HasSameDimension<au::CommonUnit<au::Trinches, au::Quarterfeet>, au::Trinches>, au::detail::HasSameMagnitude<au::CommonUnit<au::Trinches, au::Quarterfeet>, au::Trinches> >' ./au/unit_of_measure.hh:467:8: [ skipping 2 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ] ./au/unit_of_measure.hh:540:8: required from 'struct au::ComputeCommonUnit<au::Quarterfeet, au::Trinches>' ./au/quantity.hh:617:8: required from 'struct au::CommonQuantity<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>, void>' ./au/quantity.hh:630:8: required from 'struct std::common_type<au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int> >' external/sysroot_x86_64//include/c++/10.3.0/type_traits:2562:11: required by substitution of 'template<class ... _Tp> using common_type_t = typename std::common_type::type [with _Tp = {au::Quantity<au::Quarterfeet, int>, au::Quantity<au::Trinches, int>}]' ./au/quantity.hh:494:11: required from 'constexpr auto au::detail::using_common_type(T, U, Func) [with T = au::Quantity<au::Quarterfeet, int>; U = au::Quantity<au::Trinches, int>; Func = au::detail::Equal]' ./au/quantity.hh:506:37: required from 'constexpr bool au::operator==(au::Quantity<U1, R1>, au::Quantity<U2, R2>) [with U1 = au::Quarterfeet; U2 = au::Trinches; R1 = int; R2 = int]' au/error_examples.cc:84:39: required from here ./au/unit_of_measure.hh:492:70: error: static assertion failed: Elements must be listed in ascending order 492 | static_assert(AreElementsInOrder<CommonUnit, CommonUnit<Us...>>::value, | ^~~~~","title":"Broken strict total ordering"},{"location":"howto/new-units/","text":"Defining new units \u00b6 This page explains how to define new units that aren't included in the library. Tip If it's a common unit---one which should be in the library, but isn't ---go ahead and file an issue ! We should be able to turn it around pretty quickly (either adding it to the library, or explaining why we won't). Definition features \u00b6 Many libraries provide \"convenience\" macros for creating new units, but ours tries to avoid macros completely. 1 Instead, you define new units by just writing regular C++ code. There are several pieces you can add, each of which provides some particular feature. Here is a complete sample definition of a new Unit, with these features annotated and explained. C++14 C++17 or later // Example custom unit definition below. // // Items labeled with `*` are _required_; everything else is optional. // In .hh file: struct Fathoms : decltype ( Inches {} * mag < 72 > ()) { // *[1] static constexpr const char label [] = \"ftm\" ; // [2a] }; constexpr auto fathom = SingularNameFor < Fathoms > {}; // [3] constexpr auto fathoms = QuantityMaker < Fathoms > {}; // *[4] constexpr auto fathoms_pt = QuantityPointMaker < Fathoms > {}; // [5; less common] // In .cc file: constexpr const char Fathoms :: label []; // [2b] // Example custom unit definition below. // // Items labeled with `*` are _required_; everything else is optional. // In .hh file: struct Fathoms : decltype ( Inches {} * mag < 72 > ()) { // *[1] static constexpr inline const char label [] = \"ftm\" ; // [2] }; constexpr auto fathom = SingularNameFor < Fathoms > {}; // [3] constexpr auto fathoms = QuantityMaker < Fathoms > {}; // *[4] constexpr auto fathoms_pt = QuantityPointMaker < Fathoms > {}; // [5; less common] Note If you've seen the unit definitions included in our library, you may notice they look a little different from the above. That's because the library has different goals and constraints than end user projects have. For example, the library needs to be both C++14-compatible and header-only. This forces us to define our labels in a more complicated way. By contrast, your project is unlikely to have both these constraints. Prefer the simpler approach outlined in this page, instead of treating our library's source code definitions as examples to follow. Here are the features. Strong type definition . Required. Make a struct with the name you want, and inherit from decltype(u) , where u is some unit expression which gives it the right Dimension and Magnitude. (We'll explain unit expressions in the next section.) Label . A sizeof() -compatible label which is useful for printing the Unit. Note that if your project needs C++14 compatibility, then besides the label itself ( [2a] ), you'll need to provide a definition ( [2b] ) in the .cc file. By contrast, if you use C++17 or later, you can just use an inline variable, and you won't need a .cc file. If omitted: Everything will still work ; your Quantity will just be labeled as [UNLABELED UNIT] in printing contexts. Singular name . An object whose name is the singular name for your unit. Useful in certain contexts: for example, the traditional unit for torque is \" newton meters\", not \" newtons meters\". If omitted: you'll sacrifice some readability flow: the grammar becomes strange. You'll end up with constructs like speed.in(miles / hours) , rather than speed.in(miles / hour) . 2 Quantity maker . Required. This gives you a snake_case version of your unit which acts like a function. If you call this \"function\" and pass it any numeric type, it creates a Quantity of your unit , whose Rep is that type. Of course, a quantity maker is much more than a function: it composes nicely with prefixes, and with other quantity makers. Quantity point maker . Just like the quantity maker, but conventionally with a _pt suffix to indicate that it makes QuantityPoint instead. You can call this like a function on arbitrary numeric types. You can also compose it with prefixes, or scale it with Magnitudes. If omitted: this is usually fine to omit: most Units are only used with Quantity , not QuantityPoint . Note Not shown here: adding an origin member. We skipped this because it is very rare. It only has any effect at all for Units you plan to use with QuantityPoint , which is not the usual case. Even among those units, only a small subset have a non-default origin. The main examples are Celsius and Fahrenheit , and the library will provide those out of the box. Unit expressions \u00b6 Above, we said to inherit your unit's strong type from the decltype of a \"unit expression\". Recall the line from above: struct Fathoms : decltype ( Inches {} * mag < 72 > ()) { // Unit Expression ^^^^^^^^^^^^^^^^^^^^ This section explains what kinds of things can go inside of the decltype(...) . Conceptually, units are defined by combining other units . In general, given any set of units, you can multiply them, divide them, raise them to powers, or scale them by real numbers (\"magnitudes\"): the result of any of these operations defines a new unit. In C++ code, the easiest way to do this is by working with instances of the unit types. ( Meters is the type ; Meters{} is an instance of the type.) This lets us multiply them naturally by writing * , rather than using cumbersome template traits such as UnitProductT<...> . Here are some examples: Newtons: Kilo<Grams>{} * Meters{} / squared(Seconds{}) Miles: Feet{} * mag<5280>() Degrees: Radians{} * PI / mag<180>() Aliases vs. strong types: best practices \u00b6 A shorter method of defining units is as aliases for a compound unit. For example: using MilesPerHour = decltype ( Miles {} / Hours {}); constexpr auto miles_per_hour = miles / hour ; We can use the alias, MilesPerHour , anywhere we'd use a unit type. And we can call the QuantityMaker, miles_per_hour , just as we would call miles . 3 We even get an automatically generated unit label: mi / h . Despite this convenience, aliases aren't always the best choice. Here's the best practices guidance to follow. Use strong types for named units. Example: Newtons ; Fathoms Rationale: Strong types show up in compiler errors, making them easier to read. Counterpoint: as seen below, this will reduce the ability to cancel out units. For example, Meters{} * Hertz{} will not be the same as Meters{} / Seconds{} ; instead, it will be a different-but-equivalent Unit. Given the way we handle quantity-equivalent Units, this will usually not be a problem, and we believe the value of seeing shorter, more familiar names in the compiler errors outweighs this cost. Use aliases for compound units with no special name. Example: NewtonMeters ; MilesPerHour . Both of these are better implemented as aliases rather than strong types . Rationale: Keeping these as aliases increases support for cancellation: it enables the library to notice that MetersPerSecond{} * Seconds{} is identical to Meters{} , not merely quantity-equivalent. This doesn't usually matter, but it can reduce exposure to compiler errors in the (rare) situations where exact-type-equality matters (e.g., initializer lists). Macros have long been considered contrary to C++ best practices. If we're going to use one, especially in user-facing code, it needs to meet a very high bar. Unit definition macros don't meet this bar. They mostly exist to save typing. But code is read far more often than written, and macros actually make the definitions harder to read and understand (because they use positional arguments, so the meaning of the parameters is unclear at the callsite). \u21a9 Note that this requires us to build out multiplication and division between two QuantityMaker instances, rather than just a QuantityMaker and a SingularNameFor . We haven't done this yet, but it's inevitable that we will, to support composing units whose singular name is identical to the plural name (e.g., hertz ). \u21a9 Note that we don't \"need\" to define this. We could write (miles / hour)(65) , and get exactly the same result as miles_per_hour(65) . However, some users may prefer the latter syntax. \u21a9","title":"Defining new units"},{"location":"howto/new-units/#defining-new-units","text":"This page explains how to define new units that aren't included in the library. Tip If it's a common unit---one which should be in the library, but isn't ---go ahead and file an issue ! We should be able to turn it around pretty quickly (either adding it to the library, or explaining why we won't).","title":"Defining new units"},{"location":"howto/new-units/#definition-features","text":"Many libraries provide \"convenience\" macros for creating new units, but ours tries to avoid macros completely. 1 Instead, you define new units by just writing regular C++ code. There are several pieces you can add, each of which provides some particular feature. Here is a complete sample definition of a new Unit, with these features annotated and explained. C++14 C++17 or later // Example custom unit definition below. // // Items labeled with `*` are _required_; everything else is optional. // In .hh file: struct Fathoms : decltype ( Inches {} * mag < 72 > ()) { // *[1] static constexpr const char label [] = \"ftm\" ; // [2a] }; constexpr auto fathom = SingularNameFor < Fathoms > {}; // [3] constexpr auto fathoms = QuantityMaker < Fathoms > {}; // *[4] constexpr auto fathoms_pt = QuantityPointMaker < Fathoms > {}; // [5; less common] // In .cc file: constexpr const char Fathoms :: label []; // [2b] // Example custom unit definition below. // // Items labeled with `*` are _required_; everything else is optional. // In .hh file: struct Fathoms : decltype ( Inches {} * mag < 72 > ()) { // *[1] static constexpr inline const char label [] = \"ftm\" ; // [2] }; constexpr auto fathom = SingularNameFor < Fathoms > {}; // [3] constexpr auto fathoms = QuantityMaker < Fathoms > {}; // *[4] constexpr auto fathoms_pt = QuantityPointMaker < Fathoms > {}; // [5; less common] Note If you've seen the unit definitions included in our library, you may notice they look a little different from the above. That's because the library has different goals and constraints than end user projects have. For example, the library needs to be both C++14-compatible and header-only. This forces us to define our labels in a more complicated way. By contrast, your project is unlikely to have both these constraints. Prefer the simpler approach outlined in this page, instead of treating our library's source code definitions as examples to follow. Here are the features. Strong type definition . Required. Make a struct with the name you want, and inherit from decltype(u) , where u is some unit expression which gives it the right Dimension and Magnitude. (We'll explain unit expressions in the next section.) Label . A sizeof() -compatible label which is useful for printing the Unit. Note that if your project needs C++14 compatibility, then besides the label itself ( [2a] ), you'll need to provide a definition ( [2b] ) in the .cc file. By contrast, if you use C++17 or later, you can just use an inline variable, and you won't need a .cc file. If omitted: Everything will still work ; your Quantity will just be labeled as [UNLABELED UNIT] in printing contexts. Singular name . An object whose name is the singular name for your unit. Useful in certain contexts: for example, the traditional unit for torque is \" newton meters\", not \" newtons meters\". If omitted: you'll sacrifice some readability flow: the grammar becomes strange. You'll end up with constructs like speed.in(miles / hours) , rather than speed.in(miles / hour) . 2 Quantity maker . Required. This gives you a snake_case version of your unit which acts like a function. If you call this \"function\" and pass it any numeric type, it creates a Quantity of your unit , whose Rep is that type. Of course, a quantity maker is much more than a function: it composes nicely with prefixes, and with other quantity makers. Quantity point maker . Just like the quantity maker, but conventionally with a _pt suffix to indicate that it makes QuantityPoint instead. You can call this like a function on arbitrary numeric types. You can also compose it with prefixes, or scale it with Magnitudes. If omitted: this is usually fine to omit: most Units are only used with Quantity , not QuantityPoint . Note Not shown here: adding an origin member. We skipped this because it is very rare. It only has any effect at all for Units you plan to use with QuantityPoint , which is not the usual case. Even among those units, only a small subset have a non-default origin. The main examples are Celsius and Fahrenheit , and the library will provide those out of the box.","title":"Definition features"},{"location":"howto/new-units/#unit-expressions","text":"Above, we said to inherit your unit's strong type from the decltype of a \"unit expression\". Recall the line from above: struct Fathoms : decltype ( Inches {} * mag < 72 > ()) { // Unit Expression ^^^^^^^^^^^^^^^^^^^^ This section explains what kinds of things can go inside of the decltype(...) . Conceptually, units are defined by combining other units . In general, given any set of units, you can multiply them, divide them, raise them to powers, or scale them by real numbers (\"magnitudes\"): the result of any of these operations defines a new unit. In C++ code, the easiest way to do this is by working with instances of the unit types. ( Meters is the type ; Meters{} is an instance of the type.) This lets us multiply them naturally by writing * , rather than using cumbersome template traits such as UnitProductT<...> . Here are some examples: Newtons: Kilo<Grams>{} * Meters{} / squared(Seconds{}) Miles: Feet{} * mag<5280>() Degrees: Radians{} * PI / mag<180>()","title":"Unit expressions"},{"location":"howto/new-units/#aliases-vs-strong-types-best-practices","text":"A shorter method of defining units is as aliases for a compound unit. For example: using MilesPerHour = decltype ( Miles {} / Hours {}); constexpr auto miles_per_hour = miles / hour ; We can use the alias, MilesPerHour , anywhere we'd use a unit type. And we can call the QuantityMaker, miles_per_hour , just as we would call miles . 3 We even get an automatically generated unit label: mi / h . Despite this convenience, aliases aren't always the best choice. Here's the best practices guidance to follow. Use strong types for named units. Example: Newtons ; Fathoms Rationale: Strong types show up in compiler errors, making them easier to read. Counterpoint: as seen below, this will reduce the ability to cancel out units. For example, Meters{} * Hertz{} will not be the same as Meters{} / Seconds{} ; instead, it will be a different-but-equivalent Unit. Given the way we handle quantity-equivalent Units, this will usually not be a problem, and we believe the value of seeing shorter, more familiar names in the compiler errors outweighs this cost. Use aliases for compound units with no special name. Example: NewtonMeters ; MilesPerHour . Both of these are better implemented as aliases rather than strong types . Rationale: Keeping these as aliases increases support for cancellation: it enables the library to notice that MetersPerSecond{} * Seconds{} is identical to Meters{} , not merely quantity-equivalent. This doesn't usually matter, but it can reduce exposure to compiler errors in the (rare) situations where exact-type-equality matters (e.g., initializer lists). Macros have long been considered contrary to C++ best practices. If we're going to use one, especially in user-facing code, it needs to meet a very high bar. Unit definition macros don't meet this bar. They mostly exist to save typing. But code is read far more often than written, and macros actually make the definitions harder to read and understand (because they use positional arguments, so the meaning of the parameters is unclear at the callsite). \u21a9 Note that this requires us to build out multiplication and division between two QuantityMaker instances, rather than just a QuantityMaker and a SingularNameFor . We haven't done this yet, but it's inevitable that we will, to support composing units whose singular name is identical to the plural name (e.g., hertz ). \u21a9 Note that we don't \"need\" to define this. We could write (miles / hour)(65) , and get exactly the same result as miles_per_hour(65) . However, some users may prefer the latter syntax. \u21a9","title":"Aliases vs. strong types: best practices"}]}